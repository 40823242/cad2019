var tipuesearch = {"pages": [{'title': 'About', 'text': '本電腦輔助機械設計實習課程, 除了教導學生使用電腦輔助設計套件 (  Solidworks ,  NX ) 中, 各種參數式 3D 零組件設計與繪圖功能外, 也導入開源的  Solvespace ,  FreeCAD ,  V-rep  與  Webots , 讓學員了解這些中高端套件的底層所包含的各種數學原理與程式技術. 並且透過全雲端  Onshape  的協同設計, 引領學員一窺未來全球協同產品開發流程可能呈現的架構與風貌. \n 電腦輔助設計實習課程承接計算機程式與網際內容管理課程, 並與協同產品設計實習採用相同工具與理念, 希望所有學員能夠在電腦軟硬體與網路系統的充分整合應用下, 有能力透過程式方法與網際內容管理的架構, 執行創新產品開發. \n 課程工具套件: \n 2019Fall可攜套件.7z \xa0 - 計算機程式與電腦輔助設計實習共用 \n GitExtensions.7z \xa0 \xa0- 計算機程式與電腦輔助設計實習共用 \n FreeCAD 0.18.7z \xa0 \xa0- 電腦輔助設計實習課程專用 \n V-rep 3.6.1 rev 4.7z \xa0- 電腦輔助設計實習課程專用 \n Webot 2019a.7z \xa0- 電腦輔助設計實習課程專用 \n 請登入 @gm 帳號後,\xa0 填寫選課學員基本資料 \n 電腦輔助設計室與協同設計室行事曆 \n 全頁檢視 \n \n 2019 Fall 學期教育目標: \n 使用可攜程式系統與網際內容管理系統, 管理各學員與分組學習內容, 同時利用  Solidworks ,  NX , \xa0 Onshape ,  Solvespace ,  FreeCAD ,  Webots \xa0 與 \xa0 V-rep \xa0 執行機電資整合產品開發, 當面臨各種電腦輔助機械設計階段所遭遇問題時, 各學員可利用客製化程式加以解決. \n Textbooks: \n 1) 2015- Space Modeling with SolidWorks and NX \n https://link.springer.com/book/10.1007/978-3-319-03862-9 \n 2) 2008- The Engineering Design Revolution \n The Engineering Design Revolution \xa0(a.k.a. cad_history.pdf) \n 達成學期教育目標之評量方式與標準: \n 評分比例: \n 學員出席 (10%) \n 個人倉儲與網站查驗 (20%) \n Task1: 參數式繪圖軟體 Solvespace 編譯、零組件繪圖與應用 (10%) \n Task2: MCAD 套件安裝與設定, 零組件繪圖、轉檔與 CAE 工程分析 (10%) \n Task3:\xa0 Rover 零組件轉入 \xa0 V-rep \xa0 與 \xa0 Webots \xa0 執行機電控制系統設計 (20%) \n Project:\xa0 機電資整合分組專案執行 (30%) \n 評分方式: \n 電腦輔助設計實習每週自評與互評表單:  https://forms.gle/raTtrfjv8cMMVSZd6 \xa0 \n 教學方式: \n 課堂講授 \n 操作錄影 \n 學員實習 \n 分組報告 \n 參考資料: \n https://open.umn.edu/opentextbooks/subjects/engineering \xa0', 'tags': '', 'url': 'About.html'}, {'title': 'Evaluation', 'text': "電腦輔助設計實習每週自評與互評表單:\xa0 https://forms.gle/raTtrfjv8cMMVSZd6 \xa0 \n 課程計分流程: \n '''\n根據評分表單中的 自評分數, 互評得分, 教師評分, 計算學員課程成績\n'''\n \ndef diff(自評分數, 互評得分):\n    return abs(自評分數 - 互評得分)\n     \ndef max(自評分數, 互評得分):\n    if 自評分數 > 互評得分:\n        return 自評分數\n    else:\n        return 互評得分\n \ndef 分組比分(自評分數, 互評得分):\n    if diff(自評分數, 互評得分) < 5:\n        學員得分 = max(自評分數, 互評得分)\n    else:\n        學員得分 = 互評得分 - diff(自評分數, 互評得分)\n    return 學員得分\n     \ndef 全班比分(學員得分, 教師評分):\n    if diff(學員得分, 教師評分) < 5:\n        學員成績 = max(學員得分, 教師評分)\n    else:\n        學員成績 = 教師評分 - diff(學員得分, 教師評分)/4\n    return 學員成績\n \ndef 學員成績(自評分數, 互評得分, 教師評分):\n    學員分組得分 = 分組比分(自評分數, 互評得分)\n    學員課程成績 = 全班比分(學員分組得分, 教師評分)\n    return 學員課程成績\n     \nprint(學員成績(80, 70, 60))\nprint(學員成績(60, 70, 80))", 'tags': '', 'url': 'Evaluation.html'}, {'title': '課程表單', 'text': '電腦輔助設計實習每週自評與互評表單:\xa0 https://forms.gle/raTtrfjv8cMMVSZd6 \xa0(必須登入 @gm 帳號) \n 課程反應表單  (無需登入 @gm 帳號) \n', 'tags': '', 'url': '課程表單.html'}, {'title': 'Theories', 'text': 'Advanced CAD Modeling \n https://github.com/deadsy/sdfx \xa0 \n Solid Modeling and Applications \n Solid Modeling and CAD Systems \n http://mde.tw/cadp2018/downloads/intro_cad.pdf \n http://mde.tw/cadp2018/downloads/cadbook.pdf \xa0( CAD_Book.pdf ) \n 3D-Modelling-with-the-ACIS-Kernel-and-Toolkit.pdf \n http://mde.tw/cadp2018/downloads/mit_intro_cad.pdf \n http://mde.tw/cadp2018/downloads/robot_kinematics_and_dynamics.pdf \n http://mde.tw/cadp2018/downloads/Kinematics%20of%20Machines.pdf \n http://mde.tw/cadp2018/gears/Gear%20Drawing%20with%20Bezier%20Curves.pdf \n http://mde.tw/cadp2018/content/%E7%A8%8B%E5%BC%8F%E5%BA%AB%E7%AF%84%E4%BE%8B.html \n http://mde.tw/cadp2018/content/%E8%BC%94%E5%8A%A9%E8%A8%AD%E8%A8%88%E5%A5%97%E4%BB%B6.html \n http://mde.tw/cadp2018/downloads/intro_curves.pdf \n http://verbnurbs.com/ \xa0( https://github.com/pboyer/verb ) ( https://haxe.org/ ) \n https://pomax.github.io/bezierinfo/ \n https://github.com/bluecube/codecad \n https://github.com/DLR-SC/tigl', 'tags': '', 'url': 'Theories.html'}, {'title': 'Foundations', 'text': 'Mechanical Design Report DARPA BOSS Program.pdf \n Coordinate_system_and_transformations.pdf \n Optimization.pdf \n Optimization_search.pdf \n Curves.pdf \n b-spline_examples.pdf \n CAD_Data_Exchange.pdf \n', 'tags': '', 'url': 'Foundations.html'}, {'title': 'Design Theory', 'text': 'Computer-Based Design Synthesis Research - An Overview.pdf \n Implications of designer behavior for design synthesis tool interaction design.pdf \n A method based on C-K Theory for fast STCR development - The case of a drilling robot design.pdf \n Product Design and Development 2.0 Applied C-K theory -to innovate in a digital age.pdf \n IDEA GENERATION IN ENGINEERING DESIGN APPLICATION OF A MEMORY SEARCH PERSPECTIVE AND SOME EXPERIMENTAL STUDIES.pdf \n \n https://github.com/mdecourse/cd2018/issues/3 \n Design Theory - Methods and Organization for Innovation \n https://link.springer.com/book/10.1007/978-3-319-50277-9 \n Theory and Design of CNC Systems \n https://link.springer.com/book/10.1007/978-1-84800-336-1 \n An Anthology of Theories and Models of Design - Philosophy, Approaches and Empirical Explorations \n https://link.springer.com/book/10.1007/978-1-4471-6338-1 \n Control Systems Design - A New Framework \n https://link.springer.com/book/10.1007/1-84628-215-2 \n', 'tags': '', 'url': 'Design Theory.html'}, {'title': 'Optimal Design', 'text': 'Mechanical Design Optimization Using Advanced Optimization Techniques \n https://link.springer.com/book/10.1007/978-1-4471-2748-2 \xa0 \n Optimization Methods for Engineering Design \n http://apmonitor.com/me575/uploads/Main/optimization_book.pdf \xa0\xa0or \xa0 local \n https://github.com/williamhunter/topy \xa0 \n http://www.analyzemath.com/calculus.html#Calculus_Problems \n 以 \xa0 Differential Evolution \xa0 algorithm 解題: \n 以總面積 80 cm^2 的鐵皮所能焊出最大容量的方形容器: \n // 必須在演算過程中, 設法限制各變數的上下限!\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <memory.h>\n#include <time.h>\n  \n// 最大族群數, NP\n#define MAXPOP  5000\n// 最大向量維度, D\n#define MAXDIM  35\n// MAXIMAPROBLEM =1 最大化 0 最小化\n#define MAXIMAPROBLEM 1\n// 最大化時 PENALITY 必須為負值, 否則為正值\n#define PENALITY -1000\n/*\n#define MAXIMAPROBLEM 0\n#define PENALITY 1000\n*/\n  \n/*------Constants for rnd_uni()--------------------------------------------*/\n  \n#define IM1 2147483563\n#define IM2 2147483399\n#define AM (1.0/IM1)\n#define IMM1 (IM1-1)\n#define IA1 40014\n#define IA2 40692\n#define IQ1 53668\n#define IQ2 52774\n#define IR1 12211\n#define IR2 3791\n#define NTAB 32\n#define NDIV (1+IMM1/NTAB)\n#define EPS 1.2e-7\n#define RNMX (1.0-EPS)\n  \n/*------------------------Globals---------------------------------------*/\n  \nlong  rnd_uni_init;                 /* serves as a seed for rnd_uni()   */\ndouble c[MAXPOP][MAXDIM], d[MAXPOP][MAXDIM];\ndouble (*pold)[MAXPOP][MAXDIM], (*pnew)[MAXPOP][MAXDIM], (*pswap)[MAXPOP][MAXDIM];\n  \n/*---------Function declarations----------------------------------------*/\n  \nvoid  assignd(int D, double a[], double b[]);\ndouble rnd_uni(long *idum);    /* uniform pseudo random number generator */\ndouble extern evaluate(int D, double tmp[], long *nfeval); /* obj. funct. */\n  \n/*---------Function definitions-----------------------------------------*/\n// 指定向量 b 為 a\nvoid  assignd(int D, double a[], double b[])\n{\n   int j;\n   for (j=0; j<D; j++)\n   {\n      a[j] = b[j];\n   }\n}\n  \n// 產生 0 ~ 1 間的亂數\ndouble rnd_uni(long *idum)\n{\n  long j;\n  long k;\n  static long idum2=123456789;\n  static long iy=0;\n  static long iv[NTAB];\n  double temp;\n  \n  if (*idum <= 0)\n  {\n    if (-(*idum) < 1) *idum=1;\n    else *idum = -(*idum);\n    idum2=(*idum);\n    for (j=NTAB+7;j>=0;j--)\n    {\n      k=(*idum)/IQ1;\n      *idum=IA1*(*idum-k*IQ1)-k*IR1;\n      if (*idum < 0) *idum += IM1;\n      if (j < NTAB) iv[j] = *idum;\n    }\n    iy=iv[0];\n  }\n  k=(*idum)/IQ1;\n  *idum=IA1*(*idum-k*IQ1)-k*IR1;\n  if (*idum < 0) *idum += IM1;\n  k=idum2/IQ2;\n  idum2=IA2*(idum2-k*IQ2)-k*IR2;\n  if (idum2 < 0) idum2 += IM2;\n  j=iy/NDIV;\n  iy=iv[j]-idum2;\n  iv[j] = *idum;\n  if (iy < 1) iy += IMM1;\n  if ((temp=AM*iy) > RNMX) return RNMX;\n  else return temp;\n  \n}/*------End of rnd_uni()--------------------------*/\n  \n// 將上下限轉為全域變數\ndouble inibound_h;      /* upper parameter bound              */\ndouble inibound_l;      /* lower parameter bound              */\n// 與機構合成相關的全域變數\n// 宣告一個座標結構\nstruct Coord {\n    double x;\n    double y;\n  // 這裡保留 double z;\n};\n  \nmain(int argc, char *argv[])\n{\n   char  chr;             /* y/n choice variable                */\n   char  *strat[] =       /* strategy-indicator                 */\n   {\n            "",\n            "DE/best/1/exp",\n            "DE/rand/1/exp",\n            "DE/rand-to-best/1/exp",\n            "DE/best/2/exp",\n            "DE/rand/2/exp",\n            "DE/best/1/bin",\n            "DE/rand/1/bin",\n            "DE/rand-to-best/1/bin",\n            "DE/best/2/bin",\n            "DE/rand/2/bin"\n   };\n  \n   int   i, j, L, n;      /* counting variables                 */\n   int   r1, r2, r3, r4;  /* placeholders for random indexes    */\n   int   r5;              /* placeholders for random indexes    */\n   int   D;               /* Dimension of parameter vector      */\n   int   NP;              /* number of population members       */\n   int   imin;            /* index to member with lowest energy */\n   int   refresh;         /* refresh rate of screen output      */\n   int   strategy;        /* choice parameter for screen output */\n   int   gen, genmax, seed;   \n  \n   long  nfeval;          /* number of function evaluations     */\n  \n   double trial_cost;      /* buffer variable                    */\n   // 將上下限轉為全域變數, 可能要根據各變數加以設定\n   //double inibound_h;      /* upper parameter bound              */\n   //double inibound_l;      /* lower parameter bound              */\n   double tmp[MAXDIM], best[MAXDIM], bestit[MAXDIM]; /* members  */\n   double cost[MAXPOP];    /* obj. funct. values                 */\n   double cvar;            /* computes the cost variance         */\n   double cmean;           /* mean cost                          */\n   double F,CR;            /* control variables of DE            */\n   double cmin;            /* help variables                     */\n  \n   FILE  *fpin_ptr;\n   FILE  *fpout_ptr;\n  \n// 計算執行過程所需時間起點, 需要導入 time.h\n  clock_t start = clock();\n  \n/*------Initializations----------------------------*/\n  \n// 將結果寫入 out.dat\n fpout_ptr = fopen("out.dat","w");          /* open output file for reading,    */\n// 目前已經採用 strategy 3 可以得到最佳結果\n  strategy = 3;\n  genmax = 2000;\n  refresh = 100;\n  // 配合機構尺寸合成, 每一個體有 9 個機構尺寸值與 5 個通過點角度值\n  D = 2;\n  NP = 200;\n  inibound_h = 50.;\n  inibound_l = 0.;\n/*得到最佳解\n  F = 0.85;\nCR 必須介於 0 to 1. 之間\n  CR = 1.;\n*/\n  F = 0.85;\n  CR = 1.;\n  seed = 3;\n  \n //fclose(fpin_ptr);\n  \n/*-----Checking input variables for proper range----------------------------*/\n  \n  if (D > MAXDIM)\n  {\n     printf("\\nError! D=%d > MAXDIM=%d\\n",D,MAXDIM);\n     exit(1);\n  }\n  if (D <= 0)\n  {\n     printf("\\nError! D=%d, should be > 0\\n",D);\n     exit(1);\n  }\n  if (NP > MAXPOP)\n  {\n     printf("\\nError! NP=%d > MAXPOP=%d\\n",NP,MAXPOP);\n     exit(1);\n  }\n  if (NP <= 0)\n  {\n     printf("\\nError! NP=%d, should be > 0\\n",NP);\n     exit(1);\n  }\n  if ((CR < 0) || (CR > 1.0))\n  {\n     printf("\\nError! CR=%f, should be ex [0,1]\\n",CR);\n     exit(1);\n  }\n  if (seed <= 0)\n  {\n     printf("\\nError! seed=%d, should be > 0\\n",seed);\n     exit(1);\n  }\n  if (refresh <= 0)\n  {\n     printf("\\nError! refresh=%d, should be > 0\\n",refresh);\n     exit(1);\n  }\n  if (genmax <= 0)\n  {\n     printf("\\nError! genmax=%d, should be > 0\\n",genmax);\n     exit(1);\n  }\n  if ((strategy < 0) || (strategy > 10))\n  {\n     printf("\\nError! strategy=%d, should be ex {1,2,3,4,5,6,7,8,9,10}\\n",strategy);\n     exit(1);\n  }\n  if (inibound_h < inibound_l)\n  {\n     printf("\\nError! inibound_h=%f < inibound_l=%f\\n",inibound_h, inibound_l);\n     exit(1);\n  }\n  \n/*-----Initialize random number generator-----------------------------*/\n  \n rnd_uni_init = -(long)seed;  /* initialization of rnd_uni() */\n nfeval       =  0;  /* reset number of function evaluations */\n  \n/*------Initialization------------------------------------------------*/\n/*------Right now this part is kept fairly simple and just generates--*/\n/*------random numbers in the range [-initfac, +initfac]. You might---*/\n/*------want to extend the init part such that you can initialize-----*/\n/*------each parameter separately.------------------------------------*/\n  \n   for (i=0; i<NP; i++)\n   {\n      for (j=0; j<D; j++) /* spread initial population members */\n      {\n        c[i][j] = inibound_l + rnd_uni(&rnd_uni_init)*(inibound_h - inibound_l);\n      }\n      cost[i] = evaluate(D,c[i],&nfeval); /* obj. funct. value */\n   }\n   cmin = cost[0];\n   imin = 0;\n   for (i=1; i<NP; i++)\n   {\n     if(MAXIMAPROBLEM == 1)\n     {\n       // 改為最大化\n        if (cost[i]>cmin)\n        {\n          cmin = cost[i];\n          imin = i;\n        }\n      }\n      else\n      {\n        // 最小化問題\n        if (cost[i]<cmin)\n        {\n          cmin = cost[i];\n          imin = i;\n        }\n      }\n   }\n  \n   assignd(D,best,c[imin]);            /* save best member ever          */\n   assignd(D,bestit,c[imin]);          /* save best member of generation */\n  \n   pold = &c; /* old population (generation G)   */\n   pnew = &d; /* new population (generation G+1) */\n  \n/*=======================================================================*/\n/*=========Iteration loop================================================*/\n/*=======================================================================*/\n  \n   gen = 0;                          /* generation counter reset */\n   while ((gen < genmax) /*&& (kbhit() == 0)*/) /* remove comments if conio.h */\n   {                                            /* is accepted by compiler    */\n      gen++;\n      imin = 0;\n  \n      for (i=0; i<NP; i++)         /* Start of loop through ensemble  */\n      {\n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 2 !!!     */\n       r1 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while(r1==i);            \n  \n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 3 !!!     */\n       r2 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while((r2==i) || (r2==r1));\n  \n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 4 !!!     */\n       r3 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while((r3==i) || (r3==r1) || (r3==r2));\n  \n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 5 !!!     */\n       r4 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while((r4==i) || (r4==r1) || (r4==r2) || (r4==r3));\n  \n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 6 !!!     */\n       r5 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while((r5==i) || (r5==r1) || (r5==r2) || (r5==r3) || (r5==r4));\n  \n/*=======EXPONENTIAL CROSSOVER============================================================*/\n  \n/*-------DE/best/1/exp--------------------------------------------------------------------*/\n/*-------Our oldest strategy but still not bad. However, we have found several------------*/\n/*-------optimization problems where misconvergence occurs.-------------------------------*/\n     if (strategy == 1) /* strategy DE0 (not in our paper) */\n     {\n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D);\n       L = 0;\n       do\n       {                       \n         tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n/*-------DE/rand/1/exp-------------------------------------------------------------------*/\n/*-------This is one of my favourite strategies. It works especially well when the-------*/\n/*-------"bestit[]"-schemes experience misconvergence. Try e.g. F=0.7 and CR=0.5---------*/\n/*-------as a first guess.---------------------------------------------------------------*/\n     else if (strategy == 2) /* strategy DE1 in the techreport */\n     {\n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D);\n       L = 0;\n       do\n       {                       \n         tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n/*-------DE/rand-to-best/1/exp-----------------------------------------------------------*/\n/*-------This strategy seems to be one of the best strategies. Try F=0.85 and CR=1.------*/\n/*-------If you get misconvergence try to increase NP. If this doesn\'t help you----------*/\n/*-------should play around with all three control variables.----------------------------*/\n     else if (strategy == 3) /* similiar to DE2 but generally better */\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n       L = 0;\n       do\n       {                       \n         tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n/*-------DE/best/2/exp is another powerful strategy worth trying--------------------------*/\n     else if (strategy == 4)\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n       L = 0;\n       do\n       {                           \n         tmp[n] = bestit[n] + \n              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n/*-------DE/rand/2/exp seems to be a robust optimizer for many functions-------------------*/\n     else if (strategy == 5)\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n       L = 0;\n       do\n       {                           \n         tmp[n] = (*pold)[r5][n] + \n              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n  \n/*=======Essentially same strategies but BINOMIAL CROSSOVER===============================*/\n  \n/*-------DE/best/1/bin--------------------------------------------------------------------*/\n     else if (strategy == 6) \n     {\n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);\n         }\n         n = (n+1)%D;\n           }\n     }\n/*-------DE/rand/1/bin-------------------------------------------------------------------*/\n     else if (strategy == 7) \n     {\n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);\n         }\n         n = (n+1)%D;\n           }\n     }\n/*-------DE/rand-to-best/1/bin-----------------------------------------------------------*/\n     else if (strategy == 8) \n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);\n         }\n         n = (n+1)%D;\n           }\n     }\n/*-------DE/best/2/bin--------------------------------------------------------------------*/\n     else if (strategy == 9)\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = bestit[n] + \n              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;\n         }\n         n = (n+1)%D;\n           }\n     }\n/*-------DE/rand/2/bin--------------------------------------------------------------------*/\n     else\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = (*pold)[r5][n] + \n              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;\n         }\n         n = (n+1)%D;\n           }\n     }\n  \n  \n/*=======Trial mutation now in tmp[]. Test how good this choice really was.==================*/\n  \n     trial_cost = evaluate(D,tmp,&nfeval);  /* Evaluate new vector in tmp[] */\n   if(MAXIMAPROBLEM == 1)\n   {\n    // 改為最大化\n       if (trial_cost >= cost[i])   /* improved objective function value ? */\n       {                                  \n          cost[i]=trial_cost;         \n          assignd(D,(*pnew)[i],tmp);\n          if (trial_cost>cmin)          /* Was this a new minimum? */\n          {                               /* if so...*/\n             cmin=trial_cost;           /* reset cmin to new low...*/\n             imin=i;\n             assignd(D,best,tmp);           \n          }                           \n       }                            \n       else\n       {\n          assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */\n       }\n    }\n    else\n    {\n          // 最小化問題\n       if (trial_cost <= cost[i])   /* improved objective function value ? */\n       {                                  \n          cost[i]=trial_cost;         \n          assignd(D,(*pnew)[i],tmp);\n          if (trial_cost<cmin)          /* Was this a new minimum? */\n          {                               /* if so...*/\n             cmin=trial_cost;           /* reset cmin to new low...*/\n             imin=i;\n             assignd(D,best,tmp);           \n          }                           \n       }                            \n       else\n       {\n          assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */\n       }\n    }\n  \n      }   /* End mutation loop through pop. */\n  \n      assignd(D,bestit,best);  /* Save best population member of current iteration */\n  \n      /* swap population arrays. New generation becomes old one */\n  \n      pswap = pold;\n      pold  = pnew;\n      pnew  = pswap;\n  \n/*----Compute the energy variance (just for monitoring purposes)-----------*/\n  \n      cmean = 0.;          /* compute the mean value first */\n      for (j=0; j<NP; j++)\n      {\n         cmean += cost[j];\n      }\n      cmean = cmean/NP;\n  \n      cvar = 0.;           /* now the variance              */\n      for (j=0; j<NP; j++)\n      {\n         cvar += (cost[j] - cmean)*(cost[j] - cmean);\n      }\n      cvar = cvar/(NP-1);\n  \n  \n/*----Output part----------------------------------------------------------*/\n  \n      if (gen%refresh==1)   /* display after every refresh generations */\n      { /* ABORT works only if conio.h is accepted by your compiler */\n    printf("\\n\\n                         PRESS ANY KEY TO ABORT"); \n    printf("\\n\\n\\n Best-so-far cost funct. value=%-15.10g\\n",cmin);\n  \n    for (j=0;j<D;j++)\n    {\n      printf("\\n best[%d]=%-15.10g",j,best[j]);\n    }\n    printf("\\n\\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);\n    printf("\\n NP=%d    F=%-4.2g    CR=%-4.2g   cost-variance=%-10.5g\\n",\n               NP,F,CR,cvar);\n      }\n  \n      fprintf(fpout_ptr,"%ld   %-15.10g\\n",nfeval,cmin);\n   }\n/*=======================================================================*/\n/*=========End of iteration loop=========================================*/\n/*=======================================================================*/\n  \n/*-------Final output in file-------------------------------------------*/\n  \n  \n   fprintf(fpout_ptr,"\\n\\n\\n Best-so-far obj. funct. value = %-15.10g\\n",cmin);\n  \n   for (j=0;j<D;j++)\n   {\n     fprintf(fpout_ptr,"\\n best[%d]=%-15.10g",j,best[j]);\n   }\n   fprintf(fpout_ptr,"\\n\\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);\n   fprintf(fpout_ptr,"\\n NP=%d    F=%-4.2g    CR=%-4.2g    cost-variance=%-10.5g\\n",\n           NP,F,CR,cvar); \n  \n  fclose(fpout_ptr);\n  \n  /* Code you want timed here */\n  printf("Time elapsed: %f\\n", ((double)clock() - start) / CLOCKS_PER_SEC);\n   return(0);\n}\n  \n/*-----------End of main()------------------------------------------*/\n  \n// 適應函式 fittness function (cost function)\ndouble evaluate(int D, double tmp[], long *nfeval)\n{\n   double result=0, surface = 80.0, z, volume, penality;\n   (*nfeval)++;\n   z = (surface-tmp[0]*tmp[1])/(2.0*(tmp[0]+tmp[1]));\n   volume = tmp[0]*tmp[1]*z;\n  \n  if(volume <= 0){\n    return PENALITY;\n  }\n// 只限制長度與寬度必須大於 0\n  if(tmp[0] <= inibound_l){\n    return PENALITY;\n  }\n  \n  if(tmp[1] <= inibound_l){\n    return PENALITY;\n  }\n/*\n  if((tmp[0] <= inibound_l)|| (tmp[0] >inibound_h)){\n    return PENALITY;\n  }\n  \n  if((tmp[1] <= inibound_l) || (tmp[1] >inibound_h)){\n    return PENALITY;\n  }\n  */\n  // volume must >0 and max volume\n  // 目前為最小化問題\n   //return 1+1/(volume*volume);\n  return volume;\n} \n Python\xa0 Differential Evolution \xa0 algorithm: \n import random\n \nclass Chromosome(object):\n \n    """\n    just copy the idea of genetic algorithm, pretty similar..\n    """\n    def __init__(self, n):\n        """\n        int n, dimension of question\n        """\n        # dimension\n        self.n = n\n        # the gene\n        self.v = [0] * n\n        # the fitness value\n        self.f = 0\n \n    def assign(self, obj):\n        """\n        Chromosome obj\n \n        copy all attribute from obj to itself\n        """\n        self.n = obj.n\n        self.v = obj.v[:]\n        self.f = obj.f\n \n \nclass DiffertialEvolution(object):\n \n    def __init__(self,Func, pType, strategy, D, NP, F, CR, lower, upper, maxGen, report):\n        # if pType = 1 it is maximization  otherwise is minimization problem\n        self.pType = pType\n        # strategy 1~10, choice what strategy to generate new member in temporary\n        self.strategy = strategy\n        # dimesion of quesiton\n        self.D = D\n        # population size\n        # To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence\n        self.NP = NP\n        # weight factor\n        # F is usually between 0.5 and 1 (in rare cases > 1)\n        self.F = F\n        # crossover possible\n        # CR in [0,1]\n        self.CR = CR\n        # lower bound array\n        self.lb = lower[:]\n        # upper bound array\n        self.ub = upper[:]\n        # maximum generation\n        self.maxGen = maxGen\n        # how many generation report once\n        self.rpt = report\n        # object function, or enviorment\n        self.f = Func\n        # check parameter is set properly\n        self.checkParameter()\n \n        # generation pool, depend on population size\n        self.pop = [Chromosome(D) for i in range(NP)]\n        # last generation best member\n        self.lastgenbest = Chromosome(D)\n        # current best member\n        self.currentbest = Chromosome(D)\n        # the generation count\n        self.gen = 0\n        # the vector\n        self.r1 = 0\n        self.r2 = 0\n        self.r3 = 0\n        self.r4 = 0\n        self.r5 = 0\n \n    def checkParameter(self):\n        """\n        check parameter is set properly\n        """\n        if (type(self.D) is not int) and self.D <= 0:\n            raise Exception(\'D shoud be integer and larger than 0\')\n        if (type(self.NP) is not int) and self.NP <= 0:\n            raise Exception(\'NP shoud be integer and larger than 0\')\n        if self.CR < 0 or self.CR > 1:\n            raise Exception(\'CR should be [0,1]\')\n        if self.maxGen <= 0:\n            raise Exception(\'generation should larger than 0\')\n        if self.rpt <= 0 or self.rpt > self.maxGen:\n            raise Exception(\'report should be larger than 0 and less than max genration\')\n        if self.strategy < 1 or self.strategy > 10:\n            raise Exception(\'strategy should be [1,10]\')\n        for lower, upper in zip(self.lb, self.ub):\n            if lower > upper:\n                raise Exception(\'upper bound should be larger than lower bound\')\n \n    def init(self):\n        """\n        init population\n        """\n        for i in range(self.NP):\n            for j in range(self.D):\n                self.pop[i].v[j] = self.lb[j] + random.random()*(self.ub[j] - self.lb[j])\n            self.pop[i].f = self.evalute(self.pop[i])\n \n    def evalute(self, p):\n        """\n        evalute the member in enviorment\n        """\n        return self.f(p.v)\n \n    def findBest(self):\n        """\n        find member that have minimum fitness value from pool\n        """\n        if self.pType == 1:\n            return max(self.pop, key=lambda chrom:chrom.f)\n        else:\n            return min(self.pop, key=lambda chrom:chrom.f)\n \n    def generateRandomVector(self, i):\n        """\n        generate new vector\n        """\n        while True:\n            self.r1 = int(random.random() * self.NP)\n            if not (self.r1 == i):\n                break\n \n        while True:\n            self.r2 = int(random.random() * self.NP)\n            if not ((self.r2 == i) or (self.r2 == self.r1)):\n                break\n \n        while True:\n            self.r3 = int(random.random() * self.NP)\n            if not ((self.r3 == i) or (self.r3 == self.r1) or (self.r3 == self.r2)):\n                break\n \n        while True:\n            self.r4 = int(random.random() * self.NP)\n            if not ((self.r4 == i) or (self.r4 == self.r1) or (self.r4 == self.r2) or (self.r4 == self.r3)):\n                break\n \n        while True:\n            self.r5 = int(random.random() * self.NP)\n            if not ((self.r5 == i) or (self.r5 == self.r1) or (self.r5 == self.r2) or (self.r5 == self.r3) or (self.r5 == self.r4)):\n                break\n \n    def recombination(self, i):\n        """\n        use new vector, recombination the new one member to tmp\n        """\n        tmp = Chromosome(self.D)\n \n        if self.strategy == 1:\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.lastgenbest.v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n                L += 1\n                if not ((random.random() < self.CR) and (L < self.D)):\n                    break\n \n        elif self.strategy == 2:\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.pop[self.r1].v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n                L += 1\n                if not ((random.random() < self.CR) and (L < self.D)):\n                    break\n \n        elif (self.strategy == 3):\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = tmp.v[n] + self.F*(self.lastgenbest.v[n] - tmp.v[n]) + self.F*(self.pop[self.r1].v[n] - self.pop[self.r2].v[n])\n                n = (n + 1) % self.D\n                L += 1\n                if not ((random.random() < self.CR) and (L < self.D)):\n                    break\n \n        elif (self.strategy == 4):\n            tmp.assign(self.pop[i])\n \n            n = int(random.random() * self.D)\n \n            L = 0\n            while True:\n                tmp.v[n] = self.lastgenbest.v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n                L += 1\n                if not ((random.random() < self.CR) and (L < self.D)):\n                    break\n \n        elif (self.strategy == 5):\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.pop[self.r5].v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n                L += 1\n                if not ((random.random() < self.CR) and (L < self.D)):\n                    break\n \n        elif (self.strategy == 6):\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            for L in range(self.D):\n                if ((random.random() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.lastgenbest.v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n \n        elif (self.strategy == 7):\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            for L in range(self.D):\n                if ((random.random() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.pop[self.r1].v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n \n                n = (n + 1) % self.D\n \n        elif (self.strategy == 8):\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            for L in range(self.D):\n                if ((random.random() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = tmp.v[n] + self.F*(self.lastgenbest.v[n] - tmp.v[n]) + self.F*(self.pop[self.r1].v[n] - self.pop[self.r2].v[n])\n \n                n = (n + 1) % self.D\n \n        elif (self.strategy == 9):\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            for L in range(self.D):\n                if ((random.random() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.lastgenbest.v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n \n                n = (n + 1) % self.D\n \n        else:\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            for L in range(self.D):\n                if ((random.random() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.pop[self.r5].v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n        return tmp\n \n    def report(self):\n        """\n        report current generation status\n        """\n        if self.gen == 0:\n            print("DiffertialEvolution results - init pop")\n        elif self.gen == self.maxGen:\n            print("Final DiffertialEvolution results at", self.gen, "generations")\n        else:\n            print("DiffertialEvolution results after", self.gen, "generations")\n        print("Function : %.6f" % (self.currentbest.f))\n        for i, v in enumerate(self.currentbest.v, start=1):\n            print("Var", i, ":", v)\n \n    def overbound(self, member):\n        """\n        check the member\'s chromosome that is out of bound?\n        """\n        for i in range(self.D):\n            if member.v[i] > self.ub[i] or member.v[i] < self.lb[i]:\n                return True\n        return False\n \n    def run(self):\n        """\n        run the algorithm...\n        """\n        # initial step\n        # generation 0\n        self.gen = 0\n        # init the member\'s chromsome\n        self.init()\n        # find the best one(smallest fitness value)\n        tmp = self.findBest()\n        # copy to lastgenbest\n        self.lastgenbest.assign(tmp)\n        # copy to currentbest\n        self.currentbest.assign(tmp)\n        # report status\n        self.report()\n        # end initial step\n \n        # the evolution journey is beggin...\n        for self.gen in range(1, self.maxGen + 1):\n            for i in range(self.NP):\n                # generate new vector\n                self.generateRandomVector(i)\n                # use the vector recombine the member to temporary\n                tmp = self.recombination(i)\n                # check the one is out of bound?\n                if self.overbound(tmp):\n                    # if it is, then ignore\n                    continue\n                # is not out of bound, that mean it\'s quilify of enviorment\n                # then evalute the one\n                tmp.f = self.evalute(tmp)\n                # if temporary one is better than origin(fitness value is larger or smaller)\n                # pType is 1, the problem is maximization type\n                if self.pType == 1:\n                    if tmp.f >= self.pop[i].f:\n                        # copy the temporary one to origin member\n                        self.pop[i].assign(tmp)\n                        # check the temporary one is better than the currentbest\n                        if tmp.f > self.currentbest.f:\n                            # copy the temporary one to currentbest\n                            self.currentbest.assign(tmp)\n                else:\n                    if tmp.f <= self.pop[i].f:\n                        # copy the temporary one to origin member\n                        self.pop[i].assign(tmp)\n                        # check the temporary one is better than the currentbest\n                        if tmp.f < self.currentbest.f:\n                            # copy the temporary one to currentbest\n                            self.currentbest.assign(tmp)\n            # copy the currentbest to lastgenbest\n            self.lastgenbest.assign(self.currentbest)\n            # if report generation is set, report\n            if self.rpt != 0:\n                if self.gen % self.rpt == 0:\n                    self.report()\n        # the evolution journey is done, report the final status\n        self.report()\n \n#fittness function (cost function)\ndef evaluate(designVariablel):\n    surface = 80.0\n    # if pType is 1, the penality is negative (maximization problem)\n    # if pType is 0, the penality is positive (minimization problem)\n    penality = -1000\n \n    z = (surface-designVariablel[0]*designVariablel[1])/(2.0*(designVariablel[0]\\\n         +designVariablel[1]))\n    volume = designVariablel[0]*designVariablel[1]*z\n   \n    if(volume <= 0):\n        return penality\n \n    # box length and width need to be larger than 0\n    if(designVariablel[0] <= 0):\n        return penality\n \n    if(designVariablel[1] <= 0):\n        return penality\n    return volume\n#volume = DiffertialEvolution((self,Func, max, strategy, D, NP, F, CR, lower, upper, maxGen, report)\nvolume = DiffertialEvolution(evaluate, 1, 3, 2, 100, 0.6, 0.85, [0, 0], [50, 50], 100, 10)\nvolume.run() \n 為了提升運算速度, 將上述 Python 程式轉為  Cython  格式: \n #import random\nfrom cpython cimport bool\n#from array import array\nimport numpy as np\ncimport numpy as np\nfrom libc.stdlib cimport rand, RAND_MAX, srand\nfrom libc.time cimport time\n \n# make true it is random everytime\nsrand(time(NULL))\n \ncdef double randV():\n    return rand()*1.0 / RAND_MAX\n \ncdef class Chromosome(object):\n    """\n    just copy the idea of genetic algorithm, pretty similar..\n    """\n    cdef public int n\n    cdef public double f\n    cdef public np.ndarray v\n \n    def __cinit__(self, int n):\n        """\n        int n, dimension of question\n        """\n        # dimension\n        self.n = n\n        # the gene\n        self.v = np.zeros(n)\n        # the fitness value\n        self.f = 0\n \n    def assign(self, Chromosome obj):\n        """\n        Chromosome obj\n        copy all attribute from obj to itself\n        """\n        self.n = obj.n\n        self.v[:] = obj.v\n        self.f = obj.f\n \n \ncdef class DiffertialEvolution(object):\n \n    cdef:\n        int strategy, D, NP, maxGen, rpt, gen, r1, r2, r3, r4, r5\n        double F, CR\n        np.ndarray lb, ub, pop\n        object f\n        Chromosome lastgenbest, currentbest\n \n    def __cinit__(self, object Func, int strategy, int D, int NP, double F, double CR, object lower, object upper, int maxGen, int report):\n        # strategy 1~10, choice what strategy to generate new member in temporary\n        self.strategy = strategy\n        # dimesion of quesiton\n        self.D = D\n        # population size\n        # To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence\n        self.NP = NP\n        # weight factor\n        # F is usually between 0.5 and 1 (in rare cases > 1)\n        self.F = F\n        # crossover possible\n        # CR in [0,1]\n        self.CR = CR\n        # low bound\n        self.lb = np.array(lower[:])\n        # up bound\n        self.ub = np.array(upper[:])\n        # maximum generation\n        self.maxGen = maxGen\n        # how many generation report once\n        self.rpt = report\n        # object function, or enviorment\n        self.f = Func\n        # check parameter is set properly\n        self.checkParameter()\n \n        # generation pool, depend on population size\n        #self.pop = [Chromosome(self.D) for i in range(self.NP)]\n        self.pop = np.ndarray((NP,),dtype=np.object)\n        for i in range(NP):\n            self.pop[i] = Chromosome(self.D)\n        # last generation best member\n        self.lastgenbest = Chromosome(D)\n        # current best member\n        self.currentbest = Chromosome(D)\n        # the generation count\n        self.gen = 0\n        # the vector\n        self.r1 = 0\n        self.r2 = 0\n        self.r3 = 0\n        self.r4 = 0\n        self.r5 = 0\n \n    cdef void checkParameter(self):\n        """\n        check parameter is set properly\n        """\n        if (type(self.D) is not int) and self.D <= 0:\n            raise Exception(\'D shoud be integer and larger than 0\')\n        if (type(self.NP) is not int) and self.NP <= 0:\n            raise Exception(\'NP shoud be integer and larger than 0\')\n        if self.CR < 0 or self.CR > 1:\n            raise Exception(\'CR should be [0,1]\')\n        if self.maxGen <= 0:\n            raise Exception(\'generation should larger than 0\')\n        if self.rpt <= 0 or self.rpt > self.maxGen:\n            raise Exception(\'report should be larger than 0 and less than max genration\')\n        if self.strategy < 1 or self.strategy > 10:\n            raise Exception(\'strategy should be [1,10]\')\n        for lower, upper in zip(self.lb, self.ub):\n            if lower > upper:\n                raise Exception(\'upper bound should be larger than lower bound\')\n \n    cdef void init(self):\n        """\n        init population\n        """\n        cdef int i, j\n \n        for i in range(self.NP):\n            for j in range(self.D):\n                self.pop[i].v[j] = self.lb[j] + randV()*(self.ub[j] - self.lb[j])\n            self.pop[i].f = self.evalute(self.pop[i])\n \n    cdef double evalute(self, Chromosome member):\n        """\n        evalute the member in enviorment\n        """\n        return self.f(member.v)\n \n    cdef Chromosome findBest(self):\n        """\n        find member that have minimum fitness value from pool\n        """\n        return min(self.pop, key=lambda chrom:chrom.f)\n \n    cdef void generateRandomVector(self, i):\n        """\n        generate new vector\n        """\n        while True:\n            self.r1 = int(randV() * self.NP)\n            if not (self.r1 == i):\n                break\n \n        while True:\n            self.r2 = int(randV() * self.NP)\n            if not ((self.r2 == i) or (self.r2 == self.r1)):\n                break\n \n        while True:\n            self.r3 = int(randV() * self.NP)\n            if not ((self.r3 == i) or (self.r3 == self.r1) or (self.r3 == self.r2)):\n                break\n \n        while True:\n            self.r4 = int(randV() * self.NP)\n            if not ((self.r4 == i) or (self.r4 == self.r1) or (self.r4 == self.r2) or (self.r4 == self.r3)):\n                break\n \n        while True:\n            self.r5 = int(randV() * self.NP)\n            if not ((self.r5 == i) or (self.r5 == self.r1) or (self.r5 == self.r2) or (self.r5 == self.r3) or (self.r5 == self.r4)):\n                break\n \n    cdef Chromosome recombination(self, int i):\n        """\n        use new vector, recombination the new one member to tmp\n        """\n        cdef Chromosome tmp\n        cdef int n, L\n \n        tmp = Chromosome(self.D)\n \n        if self.strategy == 1:\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.lastgenbest.v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n                L += 1\n                if not ((randV() < self.CR) and (L < self.D)):\n                    break\n \n        elif self.strategy == 2:\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.pop[self.r1].v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n                L += 1\n                if not ((randV() < self.CR) and (L < self.D)):\n                    break\n \n        elif (self.strategy == 3):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = tmp.v[n] + self.F*(self.lastgenbest.v[n] - tmp.v[n]) + self.F*(self.pop[self.r1].v[n] - self.pop[self.r2].v[n])\n                n = (n + 1) % self.D\n                L += 1\n                if not ((randV() < self.CR) and (L < self.D)):\n                    break\n \n        elif (self.strategy == 4):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.lastgenbest.v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n                L += 1\n                if not ((randV() < self.CR) and (L < self.D)):\n                    break\n \n        elif (self.strategy == 5):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.pop[self.r5].v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n                L += 1\n                if not ((randV() < self.CR) and (L < self.D)):\n                    break\n \n        elif (self.strategy == 6):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            for L in range(self.D):\n                if ((randV() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.lastgenbest.v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n \n        elif (self.strategy == 7):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            for L in range(self.D):\n                if ((randV() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.pop[self.r1].v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n \n        elif (self.strategy == 8):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            for L in range(self.D):\n                if ((randV() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = tmp.v[n] + self.F*(self.lastgenbest.v[n] - tmp.v[n]) + self.F*(self.pop[self.r1].v[n] - self.pop[self.r2].v[n])\n                n = (n + 1) % self.D\n \n        elif (self.strategy == 9):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            for L in range(self.D):\n                if ((randV() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.lastgenbest.v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n \n        else:\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            for L in range(self.D):\n                if ((randV() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.pop[self.r5].v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n        return tmp\n \n    cdef void report(self):\n        """\n        report current generation status\n        """\n        cdef int i\n        cdef double v\n \n        if self.gen == 0:\n            print("DiffertialEvolution results - init pop")\n        elif self.gen == self.maxGen:\n            print("Final DiffertialEvolution results at %d generations"%(self.gen,))\n        else:\n            print("DiffertialEvolution results after %d generations"%(self.gen,))\n        print("Function : %.6f" % (self.currentbest.f))\n        for i, v in enumerate(self.currentbest.v.flat, start=1):\n            print("Var %d : %.4f"%(i, v))\n \n    cdef bool overbound(self, Chromosome member):\n        """\n        check the member\'s chromosome that is out of bound?\n        """\n        cdef int i\n \n        for i in range(self.D):\n            if member.v[i] > self.ub[i] or member.v[i] < self.lb[i]:\n                return True\n        return False\n \n    cdef void run(self):\n        """\n        run the algorithm...\n        """\n        cdef Chromosome tmp\n        cdef int i\n \n        # initial step\n        # generation 0\n        self.gen = 0\n        # init the member\'s chromsome\n        self.init()\n        # find the best one(smallest fitness value)\n        tmp = self.findBest()\n        # copy to lastgenbest\n        self.lastgenbest.assign(tmp)\n        # copy to currentbest\n        self.currentbest.assign(tmp)\n        # report status\n        self.report()\n        # end initial step\n \n        # the evolution journey is beggin...\n        for self.gen in range(1, self.maxGen + 1):\n            for i in range(self.NP):\n                # generate new vector\n                self.generateRandomVector(i)\n                # use the vector recombine the member to temporary\n                tmp = self.recombination(i)\n                # check the one is out of bound?\n                if self.overbound(tmp):\n                    # if it is, then abandon it\n                    continue\n                # is not out of bound, that mean it\'s quilify of enviorment\n                # then evalute the one\n                tmp.f = self.evalute(tmp)\n                # if temporary one is better than origin(fitness value is smaller)\n                if tmp.f <= self.pop[i].f:\n                    # copy the temporary one to origin member\n                    self.pop[i].assign(tmp)\n                    # check the temporary one is better than the currentbest\n                    if tmp.f < self.currentbest.f:\n                        # copy the temporary one to currentbest\n                        self.currentbest.assign(tmp)\n            # copy the currentbest to lastgenbest\n            self.lastgenbest.assign(self.currentbest)\n            # if report generation is set, report\n            if self.rpt != 0:\n                if self.gen % self.rpt == 0:\n                    self.report()\n        # the evolution journey is done, report the final status\n        self.report() \n 使用 Real-coded Genetic algorithm 解題: \n import time\nimport math\n \n \nclass Chromosome(object):\n \n    def __init__(self, n=None):\n        self.np = n if n > 0 else 2\n        self.f = 0.0\n        self.v = [0.0] * n\n \n    def cp(self, obj):\n        """\n        copy all atribute from another chromsome object\n        """\n        self.np = obj.np\n        self.f = obj.f\n        self.v = obj.v[:]\n \n    def get_v(self, i):\n        return self.v[i]\n \n    def is_self(self, obj):\n        """\n        check the object is self?\n        """\n        return obj is self\n \n    def assign(self, obj):\n        if not self.is_self(obj):\n            self.cp(obj)\n \n \nclass Genetic(object):\n \n    def __init__(self, func, pType, nParm, nPop, pCross, pMute, pWin, bDelta, upper, lower):\n        """\n        init(function func)\n        """\n        self.func=func\n        self.pType = pType\n        self.nParm=nParm\n        self.nPop=nPop\n        self.pCross=pCross\n        self.pMute=pMute\n        self.pWin=pWin\n        self.bDelta=bDelta\n \n        self.chrom = [Chromosome(nParm) for i in range(nPop)]\n        self.newChrom = [Chromosome(nParm) for i in range(nPop)]\n        self.babyChrom = [Chromosome(nParm) for i in range(3)]\n        self.chromElite = [Chromosome(nParm)]\n        self.chromBest = [Chromosome(nParm)]\n        self.maxLimit = upper[:]\n        self.minLimit = lower[:]\n \n        self.maxGen = None\n        self.gen = None\n \n        self.seed = 0.0\n        self.iseed = 470211272.0\n        self.mask = 2147483647\n \n    def check(self, i, v):\n        """\n        If a variable is out of bound,\n        replace it with a random value\n        """\n        if (v > self.maxLimit[i]) or (v < self.minLimit[i]):\n            return self.randVal(self.minLimit[i], self.maxLimit[i])\n        return v\n \n    def crossOver(self):\n        for i in range(0, self.nPop-1, 2):\n            # crossover\n            if(self.rnd() < self.pCross):\n                for s in range(self.nParm):\n                    # first baby, half father half mother\n                    self.babyChrom[0].v[s] = 0.5 * self.chrom[i].v[s] + 0.5*self.chrom[i+1].v[s];\n                    # second baby, three quaters of fater and quater of mother\n                    self.babyChrom[1].v[s] = self.check(s, 1.5 * self.chrom[i].v[s] - 0.5*self.chrom[i+1].v[s])\n                    # third baby, quater of fater and three quaters of mother\n                    self.babyChrom[2].v[s] = self.check(s,-0.5 * self.chrom[i].v[s] + 1.5*self.chrom[i+1].v[s]);\n \n                for j in range(3):\n                    self.babyChrom[j].f = self.func(self.babyChrom[j].v)\n                # maximization\n                if self.pType == 1:\n                     \n                    if self.babyChrom[1].f > self.babyChrom[0].f:\n                        self.babyChrom[0], self.babyChrom[1] = self.babyChrom[1], self.babyChrom[0]\n \n                    if self.babyChrom[2].f > self.babyChrom[0].f:\n                        self.babyChrom[2], self.babyChrom[0] = self.babyChrom[0], self.babyChrom[2]\n \n                    if self.babyChrom[2].f > self.babyChrom[1].f:\n                        self.babyChrom[2], self.babyChrom[1] = self.babyChrom[1], self.babyChrom[2]\n \n                else:\n                     \n                    if self.babyChrom[1].f < self.babyChrom[0].f:\n                        self.babyChrom[0], self.babyChrom[1] = self.babyChrom[1], self.babyChrom[0]\n \n                    if self.babyChrom[2].f < self.babyChrom[0].f:\n                        self.babyChrom[2], self.babyChrom[0] = self.babyChrom[0], self.babyChrom[2]\n \n                    if self.babyChrom[2].f < self.babyChrom[1].f:\n                        self.babyChrom[2], self.babyChrom[1] = self.babyChrom[1], self.babyChrom[2]\n \n                # replace first two baby to parent, another one will be\n                self.chrom[i].assign(self.babyChrom[0])\n                self.chrom[i+1].assign(self.babyChrom[1])\n \n    def delta(self, y):\n        r = float(self.gen) / self.maxGen;\n        return y*self.rnd()*math.pow(1.0-r, self.bDelta)\n \n    def fitness(self):\n        for j in range(self.nPop):\n            self.chrom[j].f = self.func(self.chrom[j].v)\n \n        self.chromBest[0].assign(self.chrom[0])\n \n        for j in range(self.nPop):\n            if self.pType == 1:\n                if(self.chrom[j].f > self.chromBest[0].f):\n                    self.chromBest[0].assign(self.chrom[j])\n            else:\n                if(self.chrom[j].f < self.chromBest[0].f):\n                    self.chromBest[0].assign(self.chrom[j])\n        if self.pType == 1:\n            if(self.chromBest[0].f > self.chromElite[0].f):\n                self.chromElite[0].assign(self.chromBest[0])\n        else:\n            if(self.chromBest[0].f < self.chromElite[0].f):\n                self.chromElite[0].assign(self.chromBest[0])\n \n    def initialPop(self):\n        for j in range(self.nPop):\n            for i in range(self.nParm):\n                self.chrom[j].v[i] = self.randVal(self.minLimit[i], self.maxLimit[i])\n \n    def mutate(self):\n        for i in range(self.nPop):\n            if self.rnd() < self.pMute:\n                s = self.random(self.nParm)\n                if (self.random(2) == 0):\n                    self.chrom[i].v[s] += self.delta(self.maxLimit[s]-self.chrom[i].v[s])\n                else:\n                    self.chrom[i].v[s] -= self.delta(self.chrom[i].v[s]-self.minLimit[s])\n \n    def report(self):\n        if self.gen == 0:\n            print("Genetik results - Initial population")\n        elif self.gen == self.maxGen:\n            print("Final Genetik results at", self.gen, "generations")\n        else:\n            print("Genetik results after", self.gen, "generations")\n \n        print("Function : %.6f" % (self.chromElite[0].f))\n        for i, p in enumerate(self.chromElite[0].v):\n            print("Var", i+1, ":", p)\n \n    def select(self):\n        """\n        roulette wheel selection\n        """\n        for i in range(self.nPop):\n            j = self.random(self.nPop)\n            k = self.random(self.nPop)\n            self.newChrom[i].assign(self.chrom[j])\n            if self.pType == 1:\n                if(self.chrom[k].f > self.chrom[j].f) and (self.rnd() > self.pWin):\n                    self.newChrom[i].assign(self.chrom[k])\n            else:\n                if(self.chrom[k].f < self.chrom[j].f) and (self.rnd() < self.pWin):\n                    self.newChrom[i].assign(self.chrom[k])\n        # in this stage, newChrom is select finish\n        # now replace origin chrom\n        for i in range(self.nPop):\n            self.chrom[i].assign(self.newChrom[i])\n \n        # select random one chrom to be best chrom, make best chrom still exist\n        j = self.random(self.nPop);\n        self.chrom[j].assign(self.chromElite[0])\n \n    def run(self, mxg, rp):\n        """\n        // **** Init and run GA for maxGen times\n        // **** mxg : maximum generation\n        // **** rp  : report cycle, 0 for final report or\n        // ****       report each mxg modulo rp\n        """\n        self.maxGen = mxg\n        self.rpt = rp\n \n        self.randomize()\n        self.initialPop()\n        self.chrom[0].f = self.func(self.chrom[0].v)\n        self.chromElite[0].assign(self.chrom[0])\n \n        self.gen = 0\n        self.fitness()\n        self.report()\n \n        for self.gen in range(1, self.maxGen + 1):\n            self.select()\n            self.crossOver()\n            self.mutate()\n            self.fitness()\n            if rp != 0:\n                if self.gen % self.rpt == 0:\n                    self.report()\n        self.report()\n \n    def newSeed(self):\n        if(self.seed == 0.0):\n            self.seed=self.iseed\n        else:\n            self.seed *= 16807.0\n            self.seed = math.fmod(self.seed, self.mask)\n \n    def rnd(self):\n        self.newSeed()\n        return self.seed/self.mask\n \n    def randomize(self):\n        self.seed = time.time()\n \n    def random(self, k):\n        return int(self.rnd()*k)\n \n    def randVal(self, low, high):\n        number_types = (int, float)\n        if isinstance(low, number_types) and isinstance(high, number_types):\n            return self.rnd()*(high-low)+low\n        raise ValueError\n         \n#fittness function (cost function)\ndef evaluate(designVariablel):\n    surface = 80.0\n    # if pType is 1, the penality is negative (maximization problem)\n    # if pType is 0, the penality is positive (minimization problem)\n    penality = -1000\n \n    z = (surface-designVariablel[0]*designVariablel[1])/(2.0*(designVariablel[0]\\\n         +designVariablel[1]))\n    volume = designVariablel[0]*designVariablel[1]*z\n   \n    if(volume <= 0):\n        return penality\n \n    # box length and width need to be larger than 0\n    if(designVariablel[0] <= 0):\n        return penality\n \n    if(designVariablel[1] <= 0):\n        return penality\n    #return 1+1/(volume*volume)\n    return volume\n \n#volume = Genetic(self, func, pType, nParm, nPop, pCross, pMute, pWin, bDelta, upper, lower):\nvolume = Genetic(evaluate, 1, 2, 1000, 0.95, 0.05, 0.95, 5, [0, 0], [50, 50])\nvolume.run(1000, 50) \n \n', 'tags': '', 'url': 'Optimal Design.html'}, {'title': 'Cloud MCAD', 'text': 'http://mde.tw/cadp2018/content/%E9%9B%B2%E7%AB%AF%20CAD.html \n University \n http://mde.tw/cadp2018/content/%E5%A4%A7%E5%AD%B8.html \n', 'tags': '', 'url': 'Cloud MCAD.html'}, {'title': 'Generative Design', 'text': 'Solving Engineering Design Problems through a Combination of Generative Grammars and Simulations.pdf \n Generative Programming.pdf \n generative representations for evoluationary design automation.pdf \n \n', 'tags': '', 'url': 'Generative Design.html'}, {'title': 'CMS', 'text': 'https://github.com/mdecourse/cmsimde \xa0的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443\xa0就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容. \n cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版. \n init.py 位於\xa0 up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數. \n 利用 cmsimde 建立靜態網誌方法: \n 1. 在 github 建立倉儲, git clone 到近端 \n 2. 參考\xa0 https://github.com/mdecourse/newcms , 加入除了 cmsimde 目錄外的所有內容 \n 以 git submodule add\xa0 https://github.com/mdecourse/cmsimde \xa0cmsimde \n 建立 cmsimde 目錄, 並從 github 取下子模組內容. \n 3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器. \n 動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端. \n 4. 之後若要以 git clone 取下包含 submodule 的所有內容, 執行: \n git clone --recurse-submodules  https://github.com/mdecourse/newcms.git \n', 'tags': '', 'url': 'CMS.html'}, {'title': 'Tools', 'text': '從未使用 Solidworks, Inventor 或 Solid Edge 等中端 MCAD 者: \n 請 登入 @gm 電子郵箱,  下載 SolidWorks 2017 SP2 安裝光碟 , 或下載已經安裝好的 \xa0 SolidWorks 2017 SP2 虛擬主機版本 , 從熟悉 Solidworks 參數繪圖與零組件設計操作開始. \n 曾經使用過中端 MCAD 者: \n 請 登入 @gm 電子郵箱,  下載 NX 12.0.2 安裝光碟 , 或者 下載 NX12.0.2 虛擬主機板本 . 隨後的零組件設計繪圖可以使用 Solidworks, Inventor 或 NX. \n 所有學員需要以學號建立  Onshape  帳號, 自行下載  Solvespace  原始碼,\xa0 根據\xa0 http://mde.tw/cp2019 \xa0中有關編譯 Solvespace 的步驟說明, 完成 Solvespace 工具的編譯, 並學習如何利用 Solvespace 建立簡單的零組件. 並嘗試從\xa0 https://github.com/KmolYuan/solvespace \xa0中建立能讓 Python 3 程式呼叫的 Geometric Constraint Solver 動態連結程式庫, 以便利用程式方法進行平面機構設計. \n 所有學員都必須下載: \n FreeCAD 0.18.7z \xa0 (登入 gm.nfu.edu.tw 後下載) - 電腦輔助設計實習課程專用 \n V-rep 3.6.1 rev 4.7z \xa0 (登入 gm.nfu.edu.tw 後下載) - 電腦輔助設計實習課程專用 \n Webot 2019a.7z \xa0 (登入 gm.nfu.edu.tw 後下載) - 電腦輔助設計實習課程專用 \n 並在各分組中探討這些工具能夠用來解決電腦輔助機械設計流程中的那些問題? \n \n \n', 'tags': '', 'url': 'Tools.html'}, {'title': 'FFmpeg', 'text': 'FFmpeg 手冊:  http://ffmpeg.org/ffmpeg.html \n 擷取 mp4 片段檔案 \n 從 origin.mp4 影片中的第一秒開始, 切出 15 分鐘的影片, 存為 new.mp4 \n ffmpeg -i origin.mp4 -ss 00:00:01 -t 00:15:00 -async 1 new.mp4 \n 刪除影片中的聲音資料 \n ffmpeg -i origin.mp4 -c copy -an new.mp4 \n 合併 mp4 檔案 \n 建立 allmp4.txt 內容為 file \'/path/to/1.mp4\' file \'/path/to/2.mp4\' file \'/path/to/3.mp4\' \n 將 1.mp4, 2.mp4 與 3.mp4 合併為 new.mp4 \n ffmpeg -f concat -i allmp4.txt -c copy new.mp4 \n 影片中加入字幕 \n 利用  http://www.aegisub.org/  可攜版本工具加入字幕 \n 直接將 input.srt 字幕資料 burn 入 input.mp4 \n ffmpeg -i input.mp4 -vf subtitles=input.srt output.mp4 \n 影片畫面中座標 x=5, y=950 位置中加入圖檔 \n \n ffmpeg -i input.mp4 -i kmol_102x30_color.png -filter_complex "overlay=5:950" output.mp4 \n 其他圖形化工具: \n http://www.aegisub.org/ \xa0(Font: SimSun, Size: 40, Bold, Primary, Color (255, 200, 5)) \n http://www.avidemux.org/nightly/win64_support/ \xa0(建立使用 2.6.21 版本, 可與 aegisub 配合使用) \n https://www.openshot.org/ \xa0(必須分段輸入字幕, 無法與 aegisub 配合使用) \n 請登入 @gm 電子郵箱後, 下載  aegisub_avidemux_openshot.7z \n \n', 'tags': '', 'url': 'FFmpeg.html'}, {'title': 'GUI', 'text': 'https://github.com/TransmissionZero/MinGW-Win32-Application \n http://cq.cx/index.pl \n https://github.com/LDmicro/LDmicro', 'tags': '', 'url': 'GUI.html'}, {'title': 'Solvespace', 'text': 'http://solvespace.com \n https://github.com/solvespace/solvespace \xa0 \n https://www.youtube.com/channel/UCPwwPIXHMZYcVyJ2SuRJjuA/videos \n 編譯步驟: \n 先將 Y:\\portablegit\\bin\\sh.exe 改名為 sh_rename_for_solvespace.exe \n git version 查驗 git 版本 \n git 2.13 版本以上, 可以使用下列 git clone\xa0 --recurse-submodules 取得所有子模組資料 \n git clone --recurse-submodules https://github.com/solvespace/solvespace.git solvespace \n edit Y:\\tmp\\solvespace\\extlib\\angle\\CMakeLists.txt comment out line 713 and 714 \n #list(APPEND ANGLE_DEFINITIONS  #"-DANGLE_PRELOADED_D3DCOMPILER_MODULE_NAMES={ \\"d3dcompiler_47.dll\\", \\"d3dcompiler_46.dll\\", \\"d3dcompiler_43.dll\\" }") endif() \n 需要手動進行 libpng.dll.a 的編譯, 並改名為 libpng_static.a, 並放到編譯系統的 lib 目錄中: \n cd solvespace \n cd extlib \n cd libpng \n mkdir build \n cd build \n cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release mingw32-make \n rename\xa0libpng.dll.a to libpng_static.a and copy to\xa0Y:\\msys64\\mingw64\\lib \n 接著回到 solvespace 原始碼目錄, 建立 build 目錄後進入 build 目錄, 執行: \n cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release mingw32-make \n 登入 @gm 後: \n 下載 Solvespace\xa0 986da7d 版本 \n 下載自行編譯的\xa0 solvespace.exe \n 下載 Solvespace 22e4011 版本 \n \n', 'tags': '', 'url': 'Solvespace.html'}, {'title': 'Onshape', 'text': 'Link Tab \n 3DX Models \n https://3dx-us.com/onshape \n PartCommunity \n Version manager \n https://cad.onshape.com/help/Content/versionmanager.htm \n Onshape and Simscale \n https://www.simscale.com/blog/2015/12/introducing-simscale-connector-app-for-onshape/ \n Simright \n Onshape and Kiri:Moto (CAM) \n https://forum.onshape.com/discussion/5081/kiri-moto-integration \n https://forum.onshape.com/discussion/8248/kiri-moto-video-guide-for-cnc-machining \n OpenBOM \n https://www.onshape.com/cad-blog/creating-a-bill-of-materials-using-openbom \n', 'tags': '', 'url': 'Onshape.html'}, {'title': 'V-rep', 'text': '登入 @gm 電子郵箱後, 可以下載  V-rep 3.6.1 rev4.7z  (139 MB) \n reading and display vision sensor image using python remoate api ( 來源 ) \n 改為 Python 3 相容 \n # -*- coding: utf-8 -*-\n"""\nCreated on Sun Jul 05 15:01:58 2015\n\n@author: ACSECKIN\n\npython -m pip install opencv-python\n"""\n\nimport vrep\nimport time\nimport cv2\nimport numpy as np\n\nvrep.simxFinish(-1)\n\nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\n\nif clientID!=-1:\n    print(\'Connected to remote API server\')\n    print(\'Vision Sensor object handling\')\n    res, v1 = vrep.simxGetObjectHandle(clientID, \'vs1\', vrep.simx_opmode_oneshot_wait)\n    print(\'Getting first image\')\n    err, resolution, image = vrep.simxGetVisionSensorImage(clientID, v1, 0, vrep.simx_opmode_streaming)\n    while (vrep.simxGetConnectionId(clientID) != -1):\n        err, resolution, image = vrep.simxGetVisionSensorImage(clientID, v1, 0, vrep.simx_opmode_buffer)\n        if err == vrep.simx_return_ok:\n            print("image OK!!!")\n            img = np.array(image,dtype=np.uint8)\n            img.resize([resolution[1],resolution[0],3])\n            cv2.imshow(\'image\',img)\n            if cv2.waitKey(1) & 0xFF == ord(\'q\'):\n                break\n        elif err == vrep.simx_return_novalue_flag:\n            print("no image yet")\n            pass\n        else:\n          print(err)\nelse:\n  print("Failed to connect to remote API Server")\n  vrep.simxFinish(clientID)\n\ncv2.destroyAllWindows() \n pythonBubbleRob.pdf \n lua_one_link_remote_api.7z \n V-rep 系統目錄中的\xa0remoteApiConnections.txt 可以同時啟動多個 port 允許多 client 連線: \n // This file defines all the continuous remote API server services (started at remote API plugin initialization, i.e. V-REP start-up)\n//\n// Each remote API server service requires following 3 entries:\n//\n// portIndex@_port = xxxx               // where xxxx is the desired port number (below 19997 are preferred for server services starting at V-REP start-up)\n// portIndex@_debug = xxxx              // where xxxx is true or false\n// portIndex@_syncSimTrigger = xxxx     // where xxxx is true or false. When true, then the service will be pre-enabled for synchronous operation.\n//\n// In above strings, @ can be any number starting with 1. If more than one server service is required, then numbers need to be consecutive and starting with 1\n\n// Let\'s start a continuous remote API server service on port 19997:\nportIndex1_port             = 19997\nportIndex1_debug            = false\nportIndex1_syncSimTrigger   = true\n\nportIndex2_port             = 19998\nportIndex2_debug            = false\nportIndex2_syncSimTrigger   = true\n \n \n 在遠端的多台電腦, 可以利用 \n clientID = vrep.simxStart(\'Server_IP\', 19997, True, True, 5000, 5) \n 與 \n clientID = vrep.simxStart(\'Server_IP\', 19998, True, True, 5000, 5) \n 同時對 rempte API server 進行操控, 各 client 並可以透過上述程式取得 rempte API Server 運作時的影像, 以便利用各 client 中的 python 程式對遠端 V-rep 模擬進行遠端操控. \n 例如: 兩名使用者分別在不同電腦上對同一台 rempte API Server 中的手足球模型進行操控競賽. \n 以下為另外一個參考程式: \n import vrep\n\nprint(\'Program started\')\nvrep.simxFinish(-1) # just in case, close all opened connections\nclientID=vrep.simxStart(\'127.0.0.1\',19999,True,True,5000,5)\nif clientID!=-1:\n    print(\'Connected to remote API server\')\n    res,v0=vrep.simxGetObjectHandle(clientID,\'Vision_sensor\',vrep.simx_opmode_oneshot_wait)\n    res,v1=vrep.simxGetObjectHandle(clientID,\'PassiveVision_sensor\',vrep.simx_opmode_oneshot_wait)\n\n    res,resolution,image=vrep.simxGetVisionSensorImage(clientID,v0,0,vrep.simx_opmode_streaming)\n    while (vrep.simxGetConnectionId(clientID)!=-1):\n        res,resolution,image=vrep.simxGetVisionSensorImage(clientID,v0,0,vrep.simx_opmode_buffer)\n        if res==vrep.simx_return_ok:\n            res=vrep.simxSetVisionSensorImage(clientID,v1,image,0,vrep.simx_opmode_oneshot)\n    vrep.simxFinish(clientID)\nelse:\n    print(\'Failed connecting to remote API server\')\nprint(\'Program ended\') \n 此外 system 目錄下的\xa0usrset.txt 可以進行客製化設定 \n \n', 'tags': '', 'url': 'V-rep.html'}, {'title': '3D Printer', 'text': 'Create Shape from path \n http://www.forum.coppeliarobotics.com/viewtopic.php?f=9&t=7920 \n Question: \n Can\xa0 http://www.coppeliarobotics.com/helpFiles/en/regularApi/simCreateMeshShape.htm \xa0be used to create virtual printing function? \n', 'tags': '', 'url': '3D Printer.html'}, {'title': 'Cyber-physical', 'text': 'Virtual vs Real Controller \n http://www.forum.coppeliarobotics.com/viewtopic.php?f=9&t=7906 \n http://www.coppeliarobotics.com/helpFiles/en/b0RemoteApiOverview.htm \n', 'tags': '', 'url': 'Cyber-physical.html'}, {'title': 'FreeCAD', 'text': 'FreeCAD 0.18.7z \xa0 (登入 gm.nfu.edu.tw 後下載) - 電腦輔助設計實習課程專用 \n', 'tags': '', 'url': 'FreeCAD.html'}, {'title': 'Webots', 'text': 'Webot 2019a.7z \xa0 (登入 gm.nfu.edu.tw 後下載) - 電腦輔助設計實習課程專用 \n', 'tags': '', 'url': 'Webots.html'}, {'title': 'Solidworks', 'text': '登入 @gm 電子郵箱, 可以 下載 SolidWorks 2017 SP2 安裝光碟 ), 或是已經安裝好的  SolidWorks 2017 SP2 虛擬主機版本 . \n Solidworks_EDU_Drawing_Exercises_2010_ENG.pdf \n Solidworks_tutorial_exercise.pdf \n SolidWorks_2010_軟體教師手冊.pdf \xa0( 英文版 ) ( 2013 版 ) \n SolidWorks_2010_ 軟體學生手冊.pdf \n SolidWorks_Tutorial08_BearingPuller_English_08_LR.pdf \n SolidWorks_Simulation_執行應力分析簡介.pdf \xa0( 英文版 ) \n SolidWorks_Simulation_Instructor_Guide_2010_ENG.pdf \n 使用 SolidWorks Simulation 執行應力 分析的簡介 講師指南.pdf \n Solidworks_Mountainboard_Design_Project_Student_2010_LR_ENG.pdf \n Solidworks_SIM_2010_HOTD_ENG.pdf \n Solidworks_2010_Bridge_Design_Project_ENG.pdf \n Solidworks_Motion_Instructor_Guide_2010_ENG.pdf \n Solidworks_Flow_Simulation_Instructor_Guide_2010_ENG.pdf \n Solidworks_CO2_Car_Project_Workbook_2010_ENG.pdf \n Solidworks_CSWPAdvancedSheetMetalSampleExam.pdf \n Solidworks_DRWT Sample Exam.pdf \n Solidworks_Sample CSWP-SURF Advanced Surfacing Certification Exam.pdf \n Solidworks_CSWP-WLDM Sample Exam.pdf \n Solidworks_CSWP-FEA Sample Exam 2011.pdf \n downloads 目錄中 Solidworks_Tutorial 子目錄中的 pdf 教學檔案 \n', 'tags': '', 'url': 'Solidworks.html'}, {'title': 'SW API', 'text': 'INTEGRATION OF MODELING IN SOLIDWORKS AND MATLAB/SIMULINK ENVIRONMENTS.pdf \n', 'tags': '', 'url': 'SW API.html'}, {'title': 'Solid Edge', 'text': 'https://www.plm.automation.siemens.com/plmapp/education/solid-edge/en_us/free-software/student \n', 'tags': '', 'url': 'Solid Edge.html'}, {'title': 'NX', 'text': 'Space Modeling with SolidWorks and NX.pdf \n', 'tags': '', 'url': 'NX.html'}, {'title': 'NX3', 'text': '登入 @gm 電子郵箱, 就可以 下載 NX3_portable.7z , 解開壓縮檔放入隨身碟, 並且連上網路擷取授權認證後, 就可以使用. \n UG-NX3-Tutorial.pdf \n UG-NX_Drafting.pdf \n nx2_UGOPEN_API.pdf \n MoldWizard_handbook .pdf \n Knowledge-Fusion.pdf \n 6539345-Knowledge-Fusion.pdf \n gears.pdf \n Gear.zip \xa0(UGOPEN example) \n UG_WAVE_ref.7z \n NX3_samples.7z \n UG_NX6_Intro-2010.pdf \n CADCAECAM_Review.pdf \n UG_NX6_Buttons.pdf \n \n', 'tags': '', 'url': 'NX3.html'}, {'title': 'NX12', 'text': '登入 @gm 電子郵箱, 可以 下載 NX 12.0.2 安裝光碟 \xa0(Windows 64 位元),  下載 Linux NX12.0.2 安裝光碟 , 或者 下載 NX12.0.2 虛擬主機板本 , 或者 下載 NX12 可攜版本 . \n 可否利用 NX12 執行  Computer Aided Virtual Manufacturing Using Creo Parametric - Easy to Learn Step by Step Guide.pdf \xa0中的所有步驟? \n How to Speed up Your NX.pdf \n NX12.0.2_release_notes.pdf \xa0( FlexNet 2015 License Administration Guide.pdf ) \n With the creation of the central runtime directory, there are two different locations for these files (nxbin and ugii), so the concept of UGII_ROOT_DIR is obsoleted. Use the UGII_BASE_DIR variable instead when you write custom application code and scripts \n The minimum recommended amount of memory to run native NX is 8GB \n SuSE Linux Enterprise Server/Desktop 12 Red Hat Enterprise Linux Server/Desktop 7 \n IPv6 Support: \n \n In license and options files, FlexNet Publisher supports only the site-local form of the IPv6 address (those prefixed with FEC0). (請注意: Virtualbox 的 Host only 網路 IPv4/IPv6 位址從控制台中的\xa0VirtualBox Host-Only Network 設定中取得, 另外當採純 IPv4 建置認證與 client 電腦之後, 可以再透過\xa0 https://www.softether.org/ \xa0建構 VPN 環境, 讓 client 可以從外部網段取得所需套件認證) \n While IPv6 address can be used in license or options files, the best-practice recommended is to use hostname or IPv4 address. \n If IPv6 address is used in the license or options file, then the FNP_IP_PRIORITY environment variable will need to be set (FNP_IP_PRIORITY=6). \n A mix of IPv4 and IPv6 addresses in the license and/or options file is not supported. \n \n FlexNet Publisher \n https://en.wikipedia.org/wiki/FlexNet_Publisher \n FlexNet Publisher v11.15.0.0 for Windows 64-bit.zip \n FlexNet Publisher 2018 R4.pdf  (Version 11.16.2) \n FlexNet Publisher v11.15.0.0 for Linux 64-bit.tgz \n https://developer.arm.com/tools-and-software/software-development-tools/license-management/downloads# \n https://helpnet.flexerasoftware.com/eol/flexnet-publisher.htm \n Siemens PLM Licensing User Guide.pdf \n NX Installation Guide for Linux and Mac OS X.pdf \n NX-12-for-Engineering-Design.pdf \n Journaling:\xa0 http://www.nxjournaling.com/content/beginning-journaling-using-nx-journal \n nxopen_getting_started_v12.pdf \n SNAP_Getting_Started_v12.pdf \n NX Nastran 12 - Release Guide.pdf \n NX12_NASTRAN_get_start.pdf \n NX Nastran 12 - Quick Reference Guide.pdf \n NX Nastran 12 - Advanced Nonlinear Theory and Modeling Guide.pdf \n', 'tags': '', 'url': 'NX12.html'}, {'title': 'Bond Graphs', 'text': 'https://github.com/mdecourse/BondGraphTools \n \n', 'tags': '', 'url': 'Bond Graphs.html'}, {'title': 'Tasks', 'text': 'Task1 \n 參數式繪圖軟體 Solvespace 編譯、零組件繪圖與應用. \n Task2 \n MCAD 套件安裝與設定, 零組件繪圖、轉檔與 CAE 工程分析. \n Task3 \n Rover 零組件轉入 \xa0 V-rep \xa0 與 \xa0 Webots \xa0 執行機電控制系統設計. \n Project \n 機電資整合分組專案執行. \n \n', 'tags': '', 'url': 'Tasks.html'}, {'title': 'Task1', 'text': '參數式繪圖軟體 Solvespace 編譯、零組件繪圖與應用. \n 利用\xa0 2019Fall可攜套件.7z \xa0學習如何完成\xa0 https://github.com/solvespace/solvespace \xa0原始碼的編譯, 並透過\xa0 http://solvespace.com \xa0學習如何建立  web_rep2.zip \xa0中所需的行走車. \n 其中必須將所建立的零組件轉入\xa0 V-rep 3.6.1 rev 4.7z \xa0進行運動組立後, 以 Lua 或 Python 進行控制. \n 網際 V-rep 模型控制:  web_vrep2.zip \xa0( local ) \n \n app.py \n from flask import Flask, render_template, redirect\nfrom vrep_linefollower import VrepLineFollower\n\nline_follower = VrepLineFollower()\n\napp = Flask(__name__)\n\n@app.route("/")\ndef index():\n  return render_template(\'controls.html\')\n\n@app.route(\'/do/<direction>\')\ndef do(direction):\n  global line_follower\n  line_follower.to_direction(direction)\n  return redirect(\'/\')\n\n\nif __name__ == \'__main__\':\n  app.run(host=\'127.0.0.1\')\n \n vrep_linefollower.py \n import vrep\n\nclass VrepLineFollower:\n  def __init__(self):\n    vrep.simxFinish(-1) # just in case, close all opened connections\n    self.clientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\n\n    self.wheelRadius = 0.027\n    self.linearVelocityLeft  = 0.1\n    self.linearVelocityRight = 0.1\n\n    # vectors [left, right]\n    self.direction_v = {\n     \'up\':    [ 0.01,  0.01],\n     \'down\':  [-0.01, -0.01],\n     \'left\':  [-0.01,  0.01],\n     \'right\': [ 0.01, -0.01]\n    }\n\n    res, self.leftJointDynamic  = vrep.simxGetObjectHandle(self.clientID, "DynamicLeftJoint",  vrep.simx_opmode_oneshot_wait)\n    res, self.rightJointDynamic = vrep.simxGetObjectHandle(self.clientID, "DynamicRightJoint", vrep.simx_opmode_oneshot_wait)\n\n  # direction = \'up\' | \'down\' | \'left\' | \'right\'\n  def to_direction(self, direction):\n    direction_vector = self.direction_v[direction]\n    self.linearVelocityLeft  += direction_vector[0]\n    self.linearVelocityRight += direction_vector[1]\n    self.set_motors()\n\n  # private\n  def set_motors(self):\n    t_left  = self.linearVelocityLeft  / self.wheelRadius\n    t_right = self.linearVelocityRight / self.wheelRadius\n    vrep.simxSetJointTargetVelocity(self.clientID, self.leftJointDynamic,  t_left,  vrep.simx_opmode_oneshot_wait)\n    vrep.simxSetJointTargetVelocity(self.clientID, self.rightJointDynamic, t_right, vrep.simx_opmode_oneshot_wait)\n\n \n', 'tags': '', 'url': 'Task1.html'}, {'title': 'Solvespace 編譯', 'text': '分組作業: \n 請各組組員分別完成 Solvespace 編譯流程後, 建立一個帶有字幕說明的導引影片, 上傳至 Youtube 並內嵌至各分組網站中. \n 下載可攜程式系統: \n 2019Fall可攜套件.7z \n 參考資料: \n https://2019wcm.blogspot.com/2019/03/msys2-solvespace.html \n https://github.com/solvespace/solvespace \n 編譯步驟: \n 先將 Y:\\portablegit\\bin\\sh.exe 改名為 sh_rename_for_solvespace.exe (透過 MSYS2 執行 shell 指令, 而非 portablegit 中的 sh.exe) \n git version 查驗 git 版本 \n git 2.13 版本以上, 可以使用下列 git clone  --recurse-submodules 取得所有子模組資料 \n git clone --recurse-submodules https://github.com/solvespace/solvespace.git solvespace \n 上述指令同: \n git clone\xa0 https://github.com/solvespace/solvespace.git \xa0 \n cd solvespace \n git submodule init \n git submodule update \n edit Y:\\tmp\\solvespace\\extlib\\angle\\CMakeLists.txt comment out line 713 and 714 \n #list(APPEND ANGLE_DEFINITIONS #"-DANGLE_PRELOADED_D3DCOMPILER_MODULE_NAMES={ \\"d3dcompiler_47.dll\\", \\"d3dcompiler_46.dll\\", \\"d3dcompiler_43.dll\\" }") endif() \n 接著需要手動進行 libpng.dll.a 的編譯, 並改名為 libpng_static.a, 並放到編譯系統的 lib 目錄中 (即隨身系統的 msys64\\mingw64\\lib 目錄): \n cd solvespace \n cd extlib \n cd libpng \n mkdir build \n cd build \n cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release mingw32-make \n (mingw32-make -Wl,-static) \n rename libpng.dll.a to libpng_static.a and copy to Y:\\msys64\\mingw64\\lib \n 接著回到 solvespace 原始碼目錄, 建立 build 目錄後進入 build 目錄, 執行: \n cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release mingw32-make \n 下載 Solvespace  986da7d 版本 \n 下載 Solvespace 22e4011 版本 \n Solvespace C++ 程式延伸 \n 位於 exposed 目錄中有一個範例 CDemo.c \n /*-----------------------------------------------------------------------------\n * Some sample code for slvs.dll. We draw some geometric entities, provide\n * initial guesses for their positions, and then constrain them. The solver\n * calculates their new positions, in order to satisfy the constraints.\n *\n * Copyright 2008-2013 Jonathan Westhues.\n *---------------------------------------------------------------------------*/\n#ifdef WIN32\n#   include <windows.h>\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n\n#include <slvs.h>\n\nstatic Slvs_System sys;\n\nstatic void *CheckMalloc(size_t n)\n{\n    void *r = malloc(n);\n    if(!r) {\n        printf("out of memory!\\n");\n        exit(-1);\n    }\n    return r;\n}\n\n/*-----------------------------------------------------------------------------\n * An example of a constraint in 3d. We create a single group, with some\n * entities and constraints.\n *---------------------------------------------------------------------------*/\nvoid Example3d()\n{\n    /* This will contain a single group, which will arbitrarily number 1. */\n    Slvs_hGroup g = 1;\n\n    /* A point, initially at (x y z) = (10 10 10) */\n    sys.param[sys.params++] = Slvs_MakeParam(1, g, 10.0);\n    sys.param[sys.params++] = Slvs_MakeParam(2, g, 10.0);\n    sys.param[sys.params++] = Slvs_MakeParam(3, g, 10.0);\n    sys.entity[sys.entities++] = Slvs_MakePoint3d(101, g, 1, 2, 3);\n    /* and a second point at (20 20 20) */\n    sys.param[sys.params++] = Slvs_MakeParam(4, g, 20.0);\n    sys.param[sys.params++] = Slvs_MakeParam(5, g, 20.0);\n    sys.param[sys.params++] = Slvs_MakeParam(6, g, 20.0);\n    sys.entity[sys.entities++] = Slvs_MakePoint3d(102, g, 4, 5, 6);\n    /* and a line segment connecting them. */\n    sys.entity[sys.entities++] = Slvs_MakeLineSegment(200, g,\n                                        SLVS_FREE_IN_3D, 101, 102);\n\n    /* The distance between the points should be 30.0 units. */\n    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(\n                                            1, g,\n                                            SLVS_C_PT_PT_DISTANCE,\n                                            SLVS_FREE_IN_3D,\n                                            30.0,\n                                            101, 102, 0, 0);\n\n    /* Let\'s tell the solver to keep the second point as close to constant\n     * as possible, instead moving the first point. */\n    sys.dragged[0] = 4;\n    sys.dragged[1] = 5;\n    sys.dragged[2] = 6;\n\n    /* Now that we have written our system, we solve. */\n    Slvs_Solve(&sys, g);\n\n    if(sys.result == SLVS_RESULT_OKAY) {\n        printf("okay; now at (%.3f %.3f %.3f)\\n"\n               "             (%.3f %.3f %.3f)\\n",\n                sys.param[0].val, sys.param[1].val, sys.param[2].val,\n                sys.param[3].val, sys.param[4].val, sys.param[5].val);\n        printf("%d DOF\\n", sys.dof);\n    } else {\n        printf("solve failed");\n    }\n}\n\n/*-----------------------------------------------------------------------------\n * An example of a constraint in 2d. In our first group, we create a workplane\n * along the reference frame\'s xy plane. In a second group, we create some\n * entities in that group and dimension them.\n *---------------------------------------------------------------------------*/\nvoid Example2d()\n{\n    Slvs_hGroup g;\n    double qw, qx, qy, qz;\n\n    g = 1;\n    /* First, we create our workplane. Its origin corresponds to the origin\n     * of our base frame (x y z) = (0 0 0) */\n    sys.param[sys.params++] = Slvs_MakeParam(1, g, 0.0);\n    sys.param[sys.params++] = Slvs_MakeParam(2, g, 0.0);\n    sys.param[sys.params++] = Slvs_MakeParam(3, g, 0.0);\n    sys.entity[sys.entities++] = Slvs_MakePoint3d(101, g, 1, 2, 3);\n    /* and it is parallel to the xy plane, so it has basis vectors (1 0 0)\n     * and (0 1 0). */\n    Slvs_MakeQuaternion(1, 0, 0,\n                        0, 1, 0, &qw, &qx, &qy, &qz);\n    sys.param[sys.params++] = Slvs_MakeParam(4, g, qw);\n    sys.param[sys.params++] = Slvs_MakeParam(5, g, qx);\n    sys.param[sys.params++] = Slvs_MakeParam(6, g, qy);\n    sys.param[sys.params++] = Slvs_MakeParam(7, g, qz);\n    sys.entity[sys.entities++] = Slvs_MakeNormal3d(102, g, 4, 5, 6, 7);\n\n    sys.entity[sys.entities++] = Slvs_MakeWorkplane(200, g, 101, 102);\n\n    /* Now create a second group. We\'ll solve group 2, while leaving group 1\n     * constant; so the workplane that we\'ve created will be locked down,\n     * and the solver can\'t move it. */\n    g = 2;\n    /* These points are represented by their coordinates (u v) within the\n     * workplane, so they need only two parameters each. */\n    sys.param[sys.params++] = Slvs_MakeParam(11, g, 10.0);\n    sys.param[sys.params++] = Slvs_MakeParam(12, g, 20.0);\n    sys.entity[sys.entities++] = Slvs_MakePoint2d(301, g, 200, 11, 12);\n\n    sys.param[sys.params++] = Slvs_MakeParam(13, g, 20.0);\n    sys.param[sys.params++] = Slvs_MakeParam(14, g, 10.0);\n    sys.entity[sys.entities++] = Slvs_MakePoint2d(302, g, 200, 13, 14);\n\n    /* And we create a line segment with those endpoints. */\n    sys.entity[sys.entities++] = Slvs_MakeLineSegment(400, g,\n                                        200, 301, 302);\n\n    /* Now three more points. */\n    sys.param[sys.params++] = Slvs_MakeParam(15, g, 100.0);\n    sys.param[sys.params++] = Slvs_MakeParam(16, g, 120.0);\n    sys.entity[sys.entities++] = Slvs_MakePoint2d(303, g, 200, 15, 16);\n\n    sys.param[sys.params++] = Slvs_MakeParam(17, g, 120.0);\n    sys.param[sys.params++] = Slvs_MakeParam(18, g, 110.0);\n    sys.entity[sys.entities++] = Slvs_MakePoint2d(304, g, 200, 17, 18);\n\n    sys.param[sys.params++] = Slvs_MakeParam(19, g, 115.0);\n    sys.param[sys.params++] = Slvs_MakeParam(20, g, 115.0);\n    sys.entity[sys.entities++] = Slvs_MakePoint2d(305, g, 200, 19, 20);\n\n    /* And arc, centered at point 303, starting at point 304, ending at\n     * point 305. */\n    sys.entity[sys.entities++] = Slvs_MakeArcOfCircle(401, g, 200, 102,\n                                    303, 304, 305);\n\n    /* Now one more point, and a distance */\n    sys.param[sys.params++] = Slvs_MakeParam(21, g, 200.0);\n    sys.param[sys.params++] = Slvs_MakeParam(22, g, 200.0);\n    sys.entity[sys.entities++] = Slvs_MakePoint2d(306, g, 200, 21, 22);\n\n    sys.param[sys.params++] = Slvs_MakeParam(23, g, 30.0);\n    sys.entity[sys.entities++] = Slvs_MakeDistance(307, g, 200, 23);\n\n    /* And a complete circle, centered at point 306 with radius equal to\n     * distance 307. The normal is 102, the same as our workplane. */\n    sys.entity[sys.entities++] = Slvs_MakeCircle(402, g, 200,\n                                    306, 102, 307);\n\n\n    /* The length of our line segment is 30.0 units. */\n    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(\n                                            1, g,\n                                            SLVS_C_PT_PT_DISTANCE,\n                                            200,\n                                            30.0,\n                                            301, 302, 0, 0);\n\n    /* And the distance from our line segment to the origin is 10.0 units. */\n    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(\n                                            2, g,\n                                            SLVS_C_PT_LINE_DISTANCE,\n                                            200,\n                                            10.0,\n                                            101, 0, 400, 0);\n    /* And the line segment is vertical. */\n    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(\n                                            3, g,\n                                            SLVS_C_VERTICAL,\n                                            200,\n                                            0.0,\n                                            0, 0, 400, 0);\n    /* And the distance from one endpoint to the origin is 15.0 units. */\n    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(\n                                            4, g,\n                                            SLVS_C_PT_PT_DISTANCE,\n                                            200,\n                                            15.0,\n                                            301, 101, 0, 0);\n#if 0\n    /* And same for the other endpoint; so if you add this constraint then\n     * the sketch is overconstrained and will signal an error. */\n    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(\n                                            5, g,\n                                            SLVS_C_PT_PT_DISTANCE,\n                                            200,\n                                            18.0,\n                                            302, 101, 0, 0);\n#endif /* 0 */\n\n    /* The arc and the circle have equal radius. */\n    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(\n                                            6, g,\n                                            SLVS_C_EQUAL_RADIUS,\n                                            200,\n                                            0.0,\n                                            0, 0, 401, 402);\n    /* The arc has radius 17.0 units. */\n    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(\n                                            7, g,\n                                            SLVS_C_DIAMETER,\n                                            200,\n                                            17.0*2,\n                                            0, 0, 401, 0);\n\n    /* If the solver fails, then ask it to report which constraints caused\n     * the problem. */\n    sys.calculateFaileds = 1;\n\n    /* And solve. */\n    Slvs_Solve(&sys, g);\n\n    if(sys.result == SLVS_RESULT_OKAY) {\n        printf("solved okay\\n");\n        printf("line from (%.3f %.3f) to (%.3f %.3f)\\n",\n                sys.param[7].val, sys.param[8].val,\n                sys.param[9].val, sys.param[10].val);\n\n        printf("arc center (%.3f %.3f) start (%.3f %.3f) finish (%.3f %.3f)\\n",\n                sys.param[11].val, sys.param[12].val,\n                sys.param[13].val, sys.param[14].val,\n                sys.param[15].val, sys.param[16].val);\n\n        printf("circle center (%.3f %.3f) radius %.3f\\n",\n                sys.param[17].val, sys.param[18].val,\n                sys.param[19].val);\n        printf("%d DOF\\n", sys.dof);\n    } else {\n        int i;\n        printf("solve failed: problematic constraints are:");\n        for(i = 0; i < sys.faileds; i++) {\n            printf(" %d", sys.failed[i]);\n        }\n        printf("\\n");\n        if(sys.result == SLVS_RESULT_INCONSISTENT) {\n            printf("system inconsistent\\n");\n        } else {\n            printf("system nonconvergent\\n");\n        }\n    }\n}\n\nint main()\n{\n    sys.param      = CheckMalloc(50*sizeof(sys.param[0]));\n    sys.entity     = CheckMalloc(50*sizeof(sys.entity[0]));\n    sys.constraint = CheckMalloc(50*sizeof(sys.constraint[0]));\n\n    sys.failed  = CheckMalloc(50*sizeof(sys.failed[0]));\n    sys.faileds = 50;\n\n    /*Example3d();*/\n    for(;;) {\n        Example2d();\n        sys.params = sys.constraints = sys.entities = 0;\n        break;\n    }\n    return 0;\n}\n\n \n 編譯 CDemo.c 流程: \n 首先將 solvespace/include/slvs.h 複製到 Y:\\msys64\\mingw64\\include \n 接著將先前 build 目錄中的 libslvs.dll 複製到 Y:\\msys64\\mingw64\\lib \n 然後在 solvespace\\exposed\\ 目錄中建立 build 目錄, 然後以指令模式進入此一 build 目錄後, 執行: \n cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release mingw32-make \n 就可以完成 CDemo.exe 的編譯, 必須配合 libslvs.dll 與 libwinpthread-1.dll 執行. \n 設計原理: \n Solvespace 首次提交到 Github \n 來源 ,  Watertight Trimmed NURBS.pdf \n SolveSpace represents curves and surfaces in a form equivalent to NURBS, by their rational polynomial parametric equations. That can represent a lot of geometry exactly, but not everything (for example, not the general intersection curve of two cylinders). When no exact representation of that form exists, SolveSpace approximates. This is the same approach that commercial libraries (Parasolid, Solids++, etc.) take. \n There\'s just a lot of cases, and a lot of work to test that you\'ve covered them all. As far as I know, the highest-quality commercial libraries get their robustness mostly from exhaustive enumeration of special cases, or trying multiple differently-broken algorithms until something works, and less from anything that\'s mathematically interesting in isolation. \n A trimming curve is typically a degree-three NURBS curve defined in the parameter domain of a NURBS surface. The image of such a trimming curve on a bicubic patch (i.e., the curve on the bicubic patch in R3 that the trimming curve maps to) is degree ≤ 18 and algebraic genus zero. However, a generic intersection curve of two bicubic surfaces is degree 324 in R3 and algebraic genus 433. Hence, intersection curves can only be approximated by parametric trimming curves. \n', 'tags': '', 'url': 'Solvespace 編譯.html'}, {'title': 'Solvespace 操作', 'text': '分組作業: \n 請各組在了解如何利用 Solvespace 執行零組件繪圖後, 以協同模式製作一個帶有中文說明字幕的 Solvespace 零組件操作導引影片, 並上傳至 Youtube 且內嵌至各分組網站. \n https://www.youtube.com/watch?v=1Em_XESnqUM&list=PLEvJVXu3VfGMSOdpA0jrGRzoM7NlNOl5s \n \n \n                      ', 'tags': '', 'url': 'Solvespace 操作.html'}, {'title': 'Task2', 'text': '分組作業: \n 請各組在實際安裝與操作 Inventor 2019、NX12、Solidworks 2017 Solidworks 2017 、Creo 6.0 與 Onshape 之後, 以協同模式製作一個帶有中文字幕的影片, 說明各套系統的安裝、認證設定與基本零組件繪圖功能後, 上傳至 Youtube 並內嵌至各分組網站中. \n MCAD 套件安裝與設定, 零組件繪圖、轉檔與 CAE 工程分析. \n 請所有組員根據\xa0 https://2019wcm.blogspot.com/2019/07/autodesk-inventor-professional.html \xa0中的說明, 在個人的桌上型電腦或筆電上安裝 AutoDesk Inventor Professional 2019. 並將詳細安裝與設定過程加以整理, 放入個人網頁中. \n 參考電子書: \n Learn Autodesk Inventor 2018 Basics - 3D Modeling, 2D Graphics, and Assembly Design \n 請每位組員 登入 @gm 電子郵箱, \xa0 下載 NX 12.0.2 安裝光碟 , 或者 下載 NX12.0.2 虛擬主機板本 , 或者 下載 NX12 可攜版本 . 以便利用 NX12 執行下列專案的零組件設計繪圖與工程分析. \n 請每位學員參考\xa0 https://github.com/nasa-jpl/open-source-rover \xa0(提供 Solidworks 零組件檔案) 與 \xa0 https://github.com/mdecourse/Sawppy_Rover \xa0(提供 \xa0 Onshape 零組件檔案 ) 中的 Rover 設計, 分別利用\xa0 Inventor 2019 與 NX12 進行 Rover 零組件的設計與繪圖. \n 參考電子書: \n 2015 Space Modeling with SolidWorks and NX \n 登入 @gm 電子郵箱後,  下載上述 Inventor_nx_sw_onshape_ebooks.7z \n \n', 'tags': '', 'url': 'Task2.html'}, {'title': 'Task3', 'text': '分組作業: \n 請各組將 Task1 所完成的行走車, 轉入 Webots, 並設法利用 Python 程式驅動行走, 完成後, 以協同模式製作一個帶有中文字幕的流程教學導引影片, 上傳至 Youtube 並內嵌至各分組網站中. \n Rover 零組件轉入  V-rep  與  Webots  執行機電控制系統設計 \n Webots 範例:\xa0 https://www.cyberbotics.com/doc/guide/sojourner \n 參考資料: \n 登入 @gm 電子郵箱後, \n 下載\xa0 Webots_reference_pdfs.7z \n 下載  Webots_2012_guide.pdf \n 下載  Vrep_reference_pdfs.7z \n', 'tags': '', 'url': 'Task3.html'}, {'title': 'Project', 'text': '機電資整合分組專案執行 \n 請各組參考先前已完成之 多段式頂球機構與循環鋼球運動系統 (例如: \xa0 1 , \xa0 2 , \xa0 3 ), 每組在 V-rep 或 Webots 中建立一個鋼球運動系統站, 並 結合 Task2 所完成的 Rover, 以執行各站鋼球搬運 \xa0 AS/RS \xa0 工作, 以組為單位, 完成結合機械設計、電子感測配置、電機驅動與程式控制的機電資整合專案. \n 完成後請 將相關過程與心得整理在分組網站, 製作一個帶有中文字幕的說明影片, 上傳至 Youtube 並內嵌至各分組網站, 過程中請利用 Blogger 網誌紀錄各階段心得, 最後再利用 Reveal 於 Week 17 進行期末分組簡報. \n Reference \n Robotics.pdf \n Mars Exploration Rover Mobility Assembly Design Test and Performance.pdf \n Lunar Rover Motion Planning and Commands.pdf \n The Challenges of Designing the Rocker-Bogie Suspension for the Mars Exploration Rover.pdf \n Kinematic State Estimation For A Mars Rover.pdf \n ATHLETE_Scene_1_After Resp Masks.ttt.7z \xa0 (V-rep Scene) \n http://mde.tw/cadp2018/content/%E5%AF%A6%E7%BF%92%E6%93%8D%E4%BD%9C.html', 'tags': '', 'url': 'Project.html'}, {'title': 'Reference', 'text': '機電資系統整合專案 \n Mechanism \n Open Chain \n Pinball Machine \n Fosball Table \n \n Closed Chain \n Leg Mechanism \n https://github.com/Rhoban/Metabot \n https://github.com/poppy-project/poppy-humanoid \n A NOVEL WALKER WITH MECHANICALLY ESTABLISHED WALKING and Standing Mechanism.pdf \n The Design and Optimization of a Crank-Based Leg Mechanism.pdf \n A_Bipedal_Mechanical_Walker_with_Balancing_Mechani.pdf \n Adjustable Power Modulation for a leg mechanism suitable for running.pdf \n Marble Machine \n \n Claw Crane \n 3D Printing \n Elevator \n Robots \n Delta Robot \n Articulated Robot \n \n ( https://hackaday.io/project/3800-3d-printable-robot-arm ) \n https://hackaday.com/2017/01/17/3d-printed-strain-wave-gear-needs-your-help/ \n \n https://github.com/BCN3D/BCN3D-Moveo \n diy_printed_robot_arm_bom.txt \xa0( source ) \n Mobil Robot \n https://linorobot.org/ \n Mars Rover (火星漫遊車) \n July 4, 1997 -  Sojourner Rover \xa0降落火星, 漫遊車長度為 65 公分, 重量 11.5 公斤, 原始設計目標漫遊 7 日, 實際運行 85 天,\xa0 \n Jan., 2004 -  Spirit and Opportunity  降落火星, 漫遊車尺寸為 L 1.6 m X W 2.3m X H 1.5m, 重量 180 公斤, 原始設計目標漫遊火星日 90 天, Spirit 實際運作了 6 年 2 個月, 而 Opportunity 則持續運作了 15 年 3 個月. \n Aug. 6, 2012 (UTC) -  Curiosity  降落火星, 漫遊車尺寸為 L 2.9m X W 2.7m X H 2.2m, 重量為 899 公斤, 原始設計預計運作 2 年, 截至 July 15, 2019 仍持續運作中. \n Mars Rover 尺寸比較: \n \n 前方為 65 公分的  Sojourner , 左側為 1.6m 長的  Spirit  與  Opportunity  同尺寸漫遊車, 而右側為 2.9m 長的  Curiosity . \n 下一輛漫遊車 ( Mars 2020 計畫 ) 預計在 2021 年 2 月 18 日降落火星, 漫遊車尺寸 L 3m X W 2.7m X H 2.2m, 重量 1050 公斤. \n Automatic Guided Vehicle \n AS/RS \n', 'tags': '', 'url': 'Reference.html'}, {'title': 'CAD2CAE', 'text': '1  autodesk_inventor_tutorial.7z \n \n Solvespace:  cad2cae_1_solvespace.slvs \n FreeCAD: \n NX12: \n Solidworks: \n Inventor: \n Onshape: \n 2 \n \n 3 \n \n 4 \n \n 5 \n \n 6 \n \n 7 \n \n 8 \n \n 9 \n \n 10 \n \n 11 \n \n 12 \n \n 13 \n \n 14 \n \n 15 \n \n 16 \n \n 17 \n \n 18 \n', 'tags': '', 'url': 'CAD2CAE.html'}]};